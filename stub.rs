// Autogenerated by Thrift Compiler (0.18.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

//
// TimError
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimError {
  pub code: Option<i32>,
  pub info: Option<String>,
}

impl TimError {
  pub fn new<F1, F2>(code: F1, info: F2) -> TimError where F1: Into<Option<i32>>, F2: Into<Option<String>> {
    TimError {
      code: code.into(),
      info: info.into(),
    }
  }
}

impl TSerializable for TimError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimError {
      code: f_1,
      info: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimError");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.info {
      o_prot.write_field_begin(&TFieldIdentifier::new("info", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimAck
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimAck {
  pub ok: bool,
  pub tim_type: i8,
  pub error: Option<TimError>,
  pub t: Option<i64>,
  pub n: Option<String>,
  pub t2: Option<i64>,
  pub n2: Option<String>,
}

impl TimAck {
  pub fn new<F3, F4, F5, F6, F7>(ok: bool, tim_type: i8, error: F3, t: F4, n: F5, t2: F6, n2: F7) -> TimAck where F3: Into<Option<TimError>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<i64>>, F7: Into<Option<String>> {
    TimAck {
      ok,
      tim_type,
      error: error.into(),
      t: t.into(),
      n: n.into(),
      t2: t2.into(),
      n2: n2.into(),
    }
  }
}

impl TSerializable for TimAck {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimAck> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i8> = None;
    let mut f_3: Option<TimError> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TimError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TimAck.ok", &f_1)?;
    verify_required_field_exists("TimAck.tim_type", &f_2)?;
    let ret = TimAck {
      ok: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tim_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
      t: f_4,
      n: f_5,
      t2: f_6,
      n2: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimAck");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ok", TType::Bool, 1))?;
    o_prot.write_bool(self.ok)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timType", TType::I08, 2))?;
    o_prot.write_i8(self.tim_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.t {
      o_prot.write_field_begin(&TFieldIdentifier::new("t", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.n {
      o_prot.write_field_begin(&TFieldIdentifier::new("n", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.t2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("t2", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.n2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("n2", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimReq
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimReq {
  pub rtype: Option<i32>,
  pub node: Option<String>,
  pub node2: Option<String>,
  pub req_int: Option<i64>,
  pub req_int2: Option<i64>,
  pub req_str: Option<String>,
  pub req_str2: Option<String>,
}

impl TimReq {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(rtype: F1, node: F2, node2: F3, req_int: F4, req_int2: F5, req_str: F6, req_str2: F7) -> TimReq where F1: Into<Option<i32>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<String>>, F7: Into<Option<String>> {
    TimReq {
      rtype: rtype.into(),
      node: node.into(),
      node2: node2.into(),
      req_int: req_int.into(),
      req_int2: req_int2.into(),
      req_str: req_str.into(),
      req_str2: req_str2.into(),
    }
  }
}

impl TSerializable for TimReq {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimReq {
      rtype: f_1,
      node: f_2,
      node2: f_3,
      req_int: f_4,
      req_int2: f_5,
      req_str: f_6,
      req_str2: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimReq");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.rtype {
      o_prot.write_field_begin(&TFieldIdentifier::new("rtype", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.node {
      o_prot.write_field_begin(&TFieldIdentifier::new("node", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.node2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("node2", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.req_int {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqInt", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.req_int2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqInt2", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.req_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqStr", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.req_str2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("reqStr2", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Tid
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Tid {
  pub node: String,
  pub domain: Option<String>,
  pub resource: Option<String>,
  pub termtyp: Option<i8>,
  pub extend: Option<BTreeMap<String, String>>,
}

impl Tid {
  pub fn new<F2, F3, F4, F5>(node: String, domain: F2, resource: F3, termtyp: F4, extend: F5) -> Tid where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i8>>, F5: Into<Option<BTreeMap<String, String>>> {
    Tid {
      node,
      domain: domain.into(),
      resource: resource.into(),
      termtyp: termtyp.into(),
      extend: extend.into(),
    }
  }
}

impl TSerializable for Tid {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Tid> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i8> = None;
    let mut f_5: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i8()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_0 = i_prot.read_string()?;
            let map_val_1 = i_prot.read_string()?;
            val.insert(map_key_0, map_val_1);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Tid.node", &f_1)?;
    let ret = Tid {
      node: f_1.expect("auto-generated code should have checked for presence of required fields"),
      domain: f_2,
      resource: f_3,
      termtyp: f_4,
      extend: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tid");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node", TType::String, 1))?;
    o_prot.write_string(&self.node)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.termtyp {
      o_prot.write_field_begin(&TFieldIdentifier::new("termtyp", TType::I08, 4))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimUserBean
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimUserBean {
  pub name: Option<String>,
  pub nick_name: Option<String>,
  pub brithday: Option<String>,
  pub gender: Option<i8>,
  pub cover: Option<String>,
  pub area: Option<String>,
  pub createtime: Option<i64>,
  pub photo_tid_album: Option<Vec<String>>,
  pub extend: Option<BTreeMap<String, String>>,
  pub extra: Option<BTreeMap<String, Vec<u8>>>,
}

impl TimUserBean {
  pub fn new<F1, F2, F4, F5, F6, F7, F8, F9, F10, F11>(name: F1, nick_name: F2, brithday: F4, gender: F5, cover: F6, area: F7, createtime: F8, photo_tid_album: F9, extend: F10, extra: F11) -> TimUserBean where F1: Into<Option<String>>, F2: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<i8>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<i64>>, F9: Into<Option<Vec<String>>>, F10: Into<Option<BTreeMap<String, String>>>, F11: Into<Option<BTreeMap<String, Vec<u8>>>> {
    TimUserBean {
      name: name.into(),
      nick_name: nick_name.into(),
      brithday: brithday.into(),
      gender: gender.into(),
      cover: cover.into(),
      area: area.into(),
      createtime: createtime.into(),
      photo_tid_album: photo_tid_album.into(),
      extend: extend.into(),
      extra: extra.into(),
    }
  }
}

impl TSerializable for TimUserBean {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimUserBean> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i8> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<Vec<String>> = None;
    let mut f_10: Option<BTreeMap<String, String>> = None;
    let mut f_11: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let map_val_4 = i_prot.read_string()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        11 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = i_prot.read_bytes()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimUserBean {
      name: f_1,
      nick_name: f_2,
      brithday: f_4,
      gender: f_5,
      cover: f_6,
      area: f_7,
      createtime: f_8,
      photo_tid_album: f_9,
      extend: f_10,
      extra: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimUserBean");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nick_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("nickName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.brithday {
      o_prot.write_field_begin(&TFieldIdentifier::new("brithday", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gender {
      o_prot.write_field_begin(&TFieldIdentifier::new("gender", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cover {
      o_prot.write_field_begin(&TFieldIdentifier::new("cover", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.area {
      o_prot.write_field_begin(&TFieldIdentifier::new("area", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.createtime {
      o_prot.write_field_begin(&TFieldIdentifier::new("createtime", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.photo_tid_album {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoTidAlbum", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extra {
      o_prot.write_field_begin(&TFieldIdentifier::new("extra", TType::Map, 11))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimRoomBean
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimRoomBean {
  pub founder: Option<String>,
  pub managers: Option<Vec<String>>,
  pub cover: Option<String>,
  pub topic: Option<String>,
  pub label: Option<String>,
  pub gtype: Option<i8>,
  pub kind: Option<i64>,
  pub createtime: Option<i64>,
  pub extend: Option<BTreeMap<String, String>>,
  pub extra: Option<BTreeMap<String, Vec<u8>>>,
}

impl TimRoomBean {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(founder: F1, managers: F2, cover: F3, topic: F4, label: F5, gtype: F6, kind: F7, createtime: F8, extend: F9, extra: F10) -> TimRoomBean where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i8>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<BTreeMap<String, String>>>, F10: Into<Option<BTreeMap<String, Vec<u8>>>> {
    TimRoomBean {
      founder: founder.into(),
      managers: managers.into(),
      cover: cover.into(),
      topic: topic.into(),
      label: label.into(),
      gtype: gtype.into(),
      kind: kind.into(),
      createtime: createtime.into(),
      extend: extend.into(),
      extra: extra.into(),
    }
  }
}

impl TSerializable for TimRoomBean {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimRoomBean> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i8> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<BTreeMap<String, String>> = None;
    let mut f_10: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i8()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_8 = i_prot.read_string()?;
            let map_val_9 = i_prot.read_string()?;
            val.insert(map_key_8, map_val_9);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_10 = i_prot.read_string()?;
            let map_val_11 = i_prot.read_bytes()?;
            val.insert(map_key_10, map_val_11);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimRoomBean {
      founder: f_1,
      managers: f_2,
      cover: f_3,
      topic: f_4,
      label: f_5,
      gtype: f_6,
      kind: f_7,
      createtime: f_8,
      extend: f_9,
      extra: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimRoomBean");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.founder {
      o_prot.write_field_begin(&TFieldIdentifier::new("founder", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.managers {
      o_prot.write_field_begin(&TFieldIdentifier::new("managers", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cover {
      o_prot.write_field_begin(&TFieldIdentifier::new("cover", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topic {
      o_prot.write_field_begin(&TFieldIdentifier::new("topic", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.label {
      o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gtype {
      o_prot.write_field_begin(&TFieldIdentifier::new("gtype", TType::I08, 6))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.createtime {
      o_prot.write_field_begin(&TFieldIdentifier::new("createtime", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extra {
      o_prot.write_field_begin(&TFieldIdentifier::new("extra", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimAuth
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimAuth {
  pub name: Option<String>,
  pub pwd: Option<String>,
  pub domain: Option<String>,
  pub resource: Option<String>,
  pub termtyp: Option<i8>,
  pub token: Option<i64>,
  pub extend: Option<BTreeMap<String, String>>,
}

impl TimAuth {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(name: F1, pwd: F2, domain: F3, resource: F4, termtyp: F5, token: F6, extend: F7) -> TimAuth where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<i8>>, F6: Into<Option<i64>>, F7: Into<Option<BTreeMap<String, String>>> {
    TimAuth {
      name: name.into(),
      pwd: pwd.into(),
      domain: domain.into(),
      resource: resource.into(),
      termtyp: termtyp.into(),
      token: token.into(),
      extend: extend.into(),
    }
  }
}

impl TSerializable for TimAuth {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimAuth> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i8> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_12 = i_prot.read_string()?;
            let map_val_13 = i_prot.read_string()?;
            val.insert(map_key_12, map_val_13);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimAuth {
      name: f_1,
      pwd: f_2,
      domain: f_3,
      resource: f_4,
      termtyp: f_5,
      token: f_6,
      extend: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimAuth");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pwd {
      o_prot.write_field_begin(&TFieldIdentifier::new("pwd", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.termtyp {
      o_prot.write_field_begin(&TFieldIdentifier::new("termtyp", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.token {
      o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimPresence
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimPresence {
  pub id: Option<i64>,
  pub offline: Option<bool>,
  pub sub_status: Option<i8>,
  pub from_tid: Option<Tid>,
  pub to_tid: Option<Tid>,
  pub to_list: Option<Vec<String>>,
  pub show: Option<i16>,
  pub status: Option<String>,
  pub extend: Option<BTreeMap<String, String>>,
  pub extra: Option<BTreeMap<String, Vec<u8>>>,
}

impl TimPresence {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(id: F1, offline: F2, sub_status: F3, from_tid: F4, to_tid: F5, to_list: F6, show: F7, status: F8, extend: F9, extra: F10) -> TimPresence where F1: Into<Option<i64>>, F2: Into<Option<bool>>, F3: Into<Option<i8>>, F4: Into<Option<Tid>>, F5: Into<Option<Tid>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<i16>>, F8: Into<Option<String>>, F9: Into<Option<BTreeMap<String, String>>>, F10: Into<Option<BTreeMap<String, Vec<u8>>>> {
    TimPresence {
      id: id.into(),
      offline: offline.into(),
      sub_status: sub_status.into(),
      from_tid: from_tid.into(),
      to_tid: to_tid.into(),
      to_list: to_list.into(),
      show: show.into(),
      status: status.into(),
      extend: extend.into(),
      extra: extra.into(),
    }
  }
}

impl TSerializable for TimPresence {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimPresence> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i8> = None;
    let mut f_4: Option<Tid> = None;
    let mut f_5: Option<Tid> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<i16> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<BTreeMap<String, String>> = None;
    let mut f_10: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i8()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Tid::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = Tid::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_string()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i16()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_15 = i_prot.read_string()?;
            let map_val_16 = i_prot.read_string()?;
            val.insert(map_key_15, map_val_16);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_17 = i_prot.read_string()?;
            let map_val_18 = i_prot.read_bytes()?;
            val.insert(map_key_17, map_val_18);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimPresence {
      id: f_1,
      offline: f_2,
      sub_status: f_3,
      from_tid: f_4,
      to_tid: f_5,
      to_list: f_6,
      show: f_7,
      status: f_8,
      extend: f_9,
      extra: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimPresence");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offline {
      o_prot.write_field_begin(&TFieldIdentifier::new("offline", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sub_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("subStatus", TType::I08, 3))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.from_tid {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromTid", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.to_tid {
      o_prot.write_field_begin(&TFieldIdentifier::new("toTid", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.to_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("toList", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.show {
      o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::I16, 7))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extra {
      o_prot.write_field_begin(&TFieldIdentifier::new("extra", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimMessage
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimMessage {
  pub ms_type: i8,
  pub od_type: i8,
  pub id: Option<i64>,
  pub mid: Option<i64>,
  pub bn_type: Option<i32>,
  pub from_tid: Option<Tid>,
  pub to_tid: Option<Tid>,
  pub room_tid: Option<Tid>,
  pub data_binary: Option<Vec<u8>>,
  pub data_string: Option<String>,
  pub is_offline: Option<bool>,
  pub timestamp: Option<i64>,
  pub udtype: Option<i16>,
  pub udshow: Option<i16>,
  pub extend: Option<BTreeMap<String, String>>,
  pub extra: Option<BTreeMap<String, Vec<u8>>>,
}

impl TimMessage {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16>(ms_type: i8, od_type: i8, id: F3, mid: F4, bn_type: F5, from_tid: F6, to_tid: F7, room_tid: F8, data_binary: F9, data_string: F10, is_offline: F11, timestamp: F12, udtype: F13, udshow: F14, extend: F15, extra: F16) -> TimMessage where F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i32>>, F6: Into<Option<Tid>>, F7: Into<Option<Tid>>, F8: Into<Option<Tid>>, F9: Into<Option<Vec<u8>>>, F10: Into<Option<String>>, F11: Into<Option<bool>>, F12: Into<Option<i64>>, F13: Into<Option<i16>>, F14: Into<Option<i16>>, F15: Into<Option<BTreeMap<String, String>>>, F16: Into<Option<BTreeMap<String, Vec<u8>>>> {
    TimMessage {
      ms_type,
      od_type,
      id: id.into(),
      mid: mid.into(),
      bn_type: bn_type.into(),
      from_tid: from_tid.into(),
      to_tid: to_tid.into(),
      room_tid: room_tid.into(),
      data_binary: data_binary.into(),
      data_string: data_string.into(),
      is_offline: is_offline.into(),
      timestamp: timestamp.into(),
      udtype: udtype.into(),
      udshow: udshow.into(),
      extend: extend.into(),
      extra: extra.into(),
    }
  }
}

impl TSerializable for TimMessage {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimMessage> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = None;
    let mut f_2: Option<i8> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<Tid> = None;
    let mut f_7: Option<Tid> = None;
    let mut f_8: Option<Tid> = None;
    let mut f_9: Option<Vec<u8>> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<i64> = None;
    let mut f_13: Option<i16> = None;
    let mut f_14: Option<i16> = None;
    let mut f_15: Option<BTreeMap<String, String>> = None;
    let mut f_16: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = Tid::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = Tid::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = Tid::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bytes()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i16()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i16()?;
          f_14 = Some(val);
        },
        15 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_19 = i_prot.read_string()?;
            let map_val_20 = i_prot.read_string()?;
            val.insert(map_key_19, map_val_20);
          }
          i_prot.read_map_end()?;
          f_15 = Some(val);
        },
        16 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_21 = i_prot.read_string()?;
            let map_val_22 = i_prot.read_bytes()?;
            val.insert(map_key_21, map_val_22);
          }
          i_prot.read_map_end()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TimMessage.ms_type", &f_1)?;
    verify_required_field_exists("TimMessage.od_type", &f_2)?;
    let ret = TimMessage {
      ms_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      od_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      id: f_3,
      mid: f_4,
      bn_type: f_5,
      from_tid: f_6,
      to_tid: f_7,
      room_tid: f_8,
      data_binary: f_9,
      data_string: f_10,
      is_offline: f_11,
      timestamp: f_12,
      udtype: f_13,
      udshow: f_14,
      extend: f_15,
      extra: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimMessage");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msType", TType::I08, 1))?;
    o_prot.write_i8(self.ms_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("odType", TType::I08, 2))?;
    o_prot.write_i8(self.od_type)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mid {
      o_prot.write_field_begin(&TFieldIdentifier::new("mid", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bn_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("bnType", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.from_tid {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromTid", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.to_tid {
      o_prot.write_field_begin(&TFieldIdentifier::new("toTid", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.room_tid {
      o_prot.write_field_begin(&TFieldIdentifier::new("roomTid", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_binary {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataBinary", TType::String, 9))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataString", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_offline {
      o_prot.write_field_begin(&TFieldIdentifier::new("isOffline", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.udtype {
      o_prot.write_field_begin(&TFieldIdentifier::new("udtype", TType::I16, 13))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.udshow {
      o_prot.write_field_begin(&TFieldIdentifier::new("udshow", TType::I16, 14))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extend {
      o_prot.write_field_begin(&TFieldIdentifier::new("extend", TType::Map, 15))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.extra {
      o_prot.write_field_begin(&TFieldIdentifier::new("extra", TType::Map, 16))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimStream
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimStream {
  pub id: i64,
  pub v_node: String,
  pub dtype: Option<i8>,
  pub body: Option<Vec<u8>>,
  pub from_node: String,
}

impl TimStream {
  pub fn new<F3, F4>(id: i64, v_node: String, dtype: F3, body: F4, from_node: String) -> TimStream where F3: Into<Option<i8>>, F4: Into<Option<Vec<u8>>> {
    TimStream {
      id,
      v_node,
      dtype: dtype.into(),
      body: body.into(),
      from_node,
    }
  }
}

impl TSerializable for TimStream {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimStream> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i8> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i8()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TimStream.id", &f_1)?;
    verify_required_field_exists("TimStream.v_node", &f_2)?;
    verify_required_field_exists("TimStream.from_node", &f_5)?;
    let ret = TimStream {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      v_node: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dtype: f_3,
      body: f_4,
      from_node: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimStream");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("VNode", TType::String, 2))?;
    o_prot.write_string(&self.v_node)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.dtype {
      o_prot.write_field_begin(&TFieldIdentifier::new("dtype", TType::I08, 3))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.body {
      o_prot.write_field_begin(&TFieldIdentifier::new("body", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("fromNode", TType::String, 5))?;
    o_prot.write_string(&self.from_node)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimNodes
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimNodes {
  pub ntype: i32,
  pub nodelist: Option<Vec<String>>,
  pub usermap: Option<BTreeMap<String, TimUserBean>>,
  pub roommap: Option<BTreeMap<String, TimRoomBean>>,
  pub node: Option<String>,
}

impl TimNodes {
  pub fn new<F2, F3, F4, F5>(ntype: i32, nodelist: F2, usermap: F3, roommap: F4, node: F5) -> TimNodes where F2: Into<Option<Vec<String>>>, F3: Into<Option<BTreeMap<String, TimUserBean>>>, F4: Into<Option<BTreeMap<String, TimRoomBean>>>, F5: Into<Option<String>> {
    TimNodes {
      ntype,
      nodelist: nodelist.into(),
      usermap: usermap.into(),
      roommap: roommap.into(),
      node: node.into(),
    }
  }
}

impl TSerializable for TimNodes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimNodes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<BTreeMap<String, TimUserBean>> = None;
    let mut f_4: Option<BTreeMap<String, TimRoomBean>> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_string()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TimUserBean> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_24 = i_prot.read_string()?;
            let map_val_25 = TimUserBean::read_from_in_protocol(i_prot)?;
            val.insert(map_key_24, map_val_25);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TimRoomBean> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_26 = i_prot.read_string()?;
            let map_val_27 = TimRoomBean::read_from_in_protocol(i_prot)?;
            val.insert(map_key_26, map_val_27);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TimNodes.ntype", &f_1)?;
    let ret = TimNodes {
      ntype: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nodelist: f_2,
      usermap: f_3,
      roommap: f_4,
      node: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimNodes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ntype", TType::I32, 1))?;
    o_prot.write_i32(self.ntype)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.nodelist {
      o_prot.write_field_begin(&TFieldIdentifier::new("nodelist", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.usermap {
      o_prot.write_field_begin(&TFieldIdentifier::new("usermap", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.roommap {
      o_prot.write_field_begin(&TFieldIdentifier::new("roommap", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.node {
      o_prot.write_field_begin(&TFieldIdentifier::new("node", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimMessageList
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimMessageList {
  pub id: Option<i64>,
  pub message_list: Option<Vec<TimMessage>>,
}

impl TimMessageList {
  pub fn new<F1, F2>(id: F1, message_list: F2) -> TimMessageList where F1: Into<Option<i64>>, F2: Into<Option<Vec<TimMessage>>> {
    TimMessageList {
      id: id.into(),
      message_list: message_list.into(),
    }
  }
}

impl TSerializable for TimMessageList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimMessageList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<TimMessage>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TimMessage> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = TimMessage::read_from_in_protocol(i_prot)?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimMessageList {
      id: f_1,
      message_list: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimMessageList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageList", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

