/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: TimError, rhs: TimError) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.info == rhs.info)
}

extension TimError : CustomStringConvertible {

  public var description : String {
    var desc = "TimError("
    desc += "code=\(String(describing: self.code)), "
    desc += "info=\(String(describing: self.info))"
    return desc
  }

}

extension TimError : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(info)
  }

}

extension TimError : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["code": 1, "info": 2, ]
  }

  public static var structName: String { return "TimError" }

  public static func read(from proto: TProtocol) throws -> TimError {
    _ = try proto.readStructBegin()
    var code: Int32?
    var info: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try Int32.read(from: proto)
        case (2, .string):           info = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimError(code: code, info: info)
  }

}



public func ==(lhs: TimAck, rhs: TimAck) -> Bool {
  return
    (lhs.ok == rhs.ok) &&
    (lhs.timType == rhs.timType) &&
    (lhs.error == rhs.error) &&
    (lhs.t == rhs.t) &&
    (lhs.n == rhs.n)
}

extension TimAck : CustomStringConvertible {

  public var description : String {
    var desc = "TimAck("
    desc += "ok=\(String(describing: self.ok)), "
    desc += "timType=\(String(describing: self.timType)), "
    desc += "error=\(String(describing: self.error)), "
    desc += "t=\(String(describing: self.t)), "
    desc += "n=\(String(describing: self.n))"
    return desc
  }

}

extension TimAck : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(ok)
    hasher.combine(timType)
    hasher.combine(error)
    hasher.combine(t)
    hasher.combine(n)
  }

}

extension TimAck : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["ok": 1, "timType": 2, "error": 3, "t": 4, "n": 5, ]
  }

  public static var structName: String { return "TimAck" }

  public static func read(from proto: TProtocol) throws -> TimAck {
    _ = try proto.readStructBegin()
    var ok: Bool!
    var timType: Int8!
    var error: TimError?
    var t: Int64?
    var n: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            ok = try Bool.read(from: proto)
        case (2, .i8):            timType = try Int8.read(from: proto)
        case (3, .struct):           error = try TimError.read(from: proto)
        case (4, .i64):             t = try Int64.read(from: proto)
        case (5, .string):           n = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ok, named: "ok")
    try proto.validateValue(timType, named: "timType")

    return TimAck(ok: ok, timType: timType, error: error, t: t, n: n)
  }

}



public func ==(lhs: TimReq, rhs: TimReq) -> Bool {
  return
    (lhs.rtype == rhs.rtype) &&
    (lhs.node == rhs.node) &&
    (lhs.node2 == rhs.node2) &&
    (lhs.reqInt == rhs.reqInt) &&
    (lhs.reqInt2 == rhs.reqInt2) &&
    (lhs.reqStr == rhs.reqStr) &&
    (lhs.reqStr2 == rhs.reqStr2)
}

extension TimReq : CustomStringConvertible {

  public var description : String {
    var desc = "TimReq("
    desc += "rtype=\(String(describing: self.rtype)), "
    desc += "node=\(String(describing: self.node)), "
    desc += "node2=\(String(describing: self.node2)), "
    desc += "reqInt=\(String(describing: self.reqInt)), "
    desc += "reqInt2=\(String(describing: self.reqInt2)), "
    desc += "reqStr=\(String(describing: self.reqStr)), "
    desc += "reqStr2=\(String(describing: self.reqStr2))"
    return desc
  }

}

extension TimReq : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(rtype)
    hasher.combine(node)
    hasher.combine(node2)
    hasher.combine(reqInt)
    hasher.combine(reqInt2)
    hasher.combine(reqStr)
    hasher.combine(reqStr2)
  }

}

extension TimReq : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["rtype": 1, "node": 2, "node2": 3, "reqInt": 4, "reqInt2": 5, "reqStr": 6, "reqStr2": 7, ]
  }

  public static var structName: String { return "TimReq" }

  public static func read(from proto: TProtocol) throws -> TimReq {
    _ = try proto.readStructBegin()
    var rtype: Int32?
    var node: String?
    var node2: String?
    var reqInt: Int64?
    var reqInt2: Int64?
    var reqStr: String?
    var reqStr2: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             rtype = try Int32.read(from: proto)
        case (2, .string):           node = try String.read(from: proto)
        case (3, .string):           node2 = try String.read(from: proto)
        case (4, .i64):             reqInt = try Int64.read(from: proto)
        case (5, .i64):             reqInt2 = try Int64.read(from: proto)
        case (6, .string):           reqStr = try String.read(from: proto)
        case (7, .string):           reqStr2 = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimReq(rtype: rtype, node: node, node2: node2, reqInt: reqInt, reqInt2: reqInt2, reqStr: reqStr, reqStr2: reqStr2)
  }

}



public func ==(lhs: Tid, rhs: Tid) -> Bool {
  return
    (lhs.node == rhs.node) &&
    (lhs.domain == rhs.domain) &&
    (lhs.resource == rhs.resource) &&
    (lhs.termtyp == rhs.termtyp) &&
    (lhs.extend == rhs.extend)
}

extension Tid : CustomStringConvertible {

  public var description : String {
    var desc = "Tid("
    desc += "node=\(String(describing: self.node)), "
    desc += "domain=\(String(describing: self.domain)), "
    desc += "resource=\(String(describing: self.resource)), "
    desc += "termtyp=\(String(describing: self.termtyp)), "
    desc += "extend=\(String(describing: self.extend))"
    return desc
  }

}

extension Tid : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(node)
    hasher.combine(domain)
    hasher.combine(resource)
    hasher.combine(termtyp)
    hasher.combine(extend)
  }

}

extension Tid : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["node": 1, "domain": 2, "resource": 3, "termtyp": 4, "extend": 5, ]
  }

  public static var structName: String { return "Tid" }

  public static func read(from proto: TProtocol) throws -> Tid {
    _ = try proto.readStructBegin()
    var node: String!
    var domain: String?
    var resource: String?
    var termtyp: Int8?
    var extend: TMap<String, String>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           node = try String.read(from: proto)
        case (2, .string):           domain = try String.read(from: proto)
        case (3, .string):           resource = try String.read(from: proto)
        case (4, .i8):            termtyp = try Int8.read(from: proto)
        case (5, .map):             extend = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(node, named: "node")

    return Tid(node: node, domain: domain, resource: resource, termtyp: termtyp, extend: extend)
  }

}



public func ==(lhs: TimUserBean, rhs: TimUserBean) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.nickName == rhs.nickName) &&
    (lhs.brithday == rhs.brithday) &&
    (lhs.gender == rhs.gender) &&
    (lhs.cover == rhs.cover) &&
    (lhs.area == rhs.area) &&
    (lhs.createtime == rhs.createtime) &&
    (lhs.photoTidAlbum == rhs.photoTidAlbum) &&
    (lhs.extend == rhs.extend) &&
    (lhs.extra == rhs.extra)
}

extension TimUserBean : CustomStringConvertible {

  public var description : String {
    var desc = "TimUserBean("
    desc += "name=\(String(describing: self.name)), "
    desc += "nickName=\(String(describing: self.nickName)), "
    desc += "brithday=\(String(describing: self.brithday)), "
    desc += "gender=\(String(describing: self.gender)), "
    desc += "cover=\(String(describing: self.cover)), "
    desc += "area=\(String(describing: self.area)), "
    desc += "createtime=\(String(describing: self.createtime)), "
    desc += "photoTidAlbum=\(String(describing: self.photoTidAlbum)), "
    desc += "extend=\(String(describing: self.extend)), "
    desc += "extra=\(String(describing: self.extra))"
    return desc
  }

}

extension TimUserBean : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(name)
    hasher.combine(nickName)
    hasher.combine(brithday)
    hasher.combine(gender)
    hasher.combine(cover)
    hasher.combine(area)
    hasher.combine(createtime)
    hasher.combine(photoTidAlbum)
    hasher.combine(extend)
    hasher.combine(extra)
  }

}

extension TimUserBean : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, "nickName": 2, "brithday": 4, "gender": 5, "cover": 6, "area": 7, "createtime": 8, "photoTidAlbum": 9, "extend": 10, "extra": 11, ]
  }

  public static var structName: String { return "TimUserBean" }

  public static func read(from proto: TProtocol) throws -> TimUserBean {
    _ = try proto.readStructBegin()
    var name: String?
    var nickName: String?
    var brithday: String?
    var gender: Int8?
    var cover: String?
    var area: String?
    var createtime: Int64?
    var photoTidAlbum: TList<String>?
    var extend: TMap<String, String>?
    var extra: TMap<String, Data>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case (2, .string):           nickName = try String.read(from: proto)
        case (4, .string):           brithday = try String.read(from: proto)
        case (5, .i8):            gender = try Int8.read(from: proto)
        case (6, .string):           cover = try String.read(from: proto)
        case (7, .string):           area = try String.read(from: proto)
        case (8, .i64):             createtime = try Int64.read(from: proto)
        case (9, .list):            photoTidAlbum = try TList<String>.read(from: proto)
        case (10, .map):             extend = try TMap<String, String>.read(from: proto)
        case (11, .map):             extra = try TMap<String, Data>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimUserBean(name: name, nickName: nickName, brithday: brithday, gender: gender, cover: cover, area: area, createtime: createtime, photoTidAlbum: photoTidAlbum, extend: extend, extra: extra)
  }

}



public func ==(lhs: TimRoomBean, rhs: TimRoomBean) -> Bool {
  return
    (lhs.founder == rhs.founder) &&
    (lhs.managers == rhs.managers) &&
    (lhs.cover == rhs.cover) &&
    (lhs.topic == rhs.topic) &&
    (lhs.label == rhs.label) &&
    (lhs.gtype == rhs.gtype) &&
    (lhs.createtime == rhs.createtime) &&
    (lhs.extend == rhs.extend) &&
    (lhs.extra == rhs.extra)
}

extension TimRoomBean : CustomStringConvertible {

  public var description : String {
    var desc = "TimRoomBean("
    desc += "founder=\(String(describing: self.founder)), "
    desc += "managers=\(String(describing: self.managers)), "
    desc += "cover=\(String(describing: self.cover)), "
    desc += "topic=\(String(describing: self.topic)), "
    desc += "label=\(String(describing: self.label)), "
    desc += "gtype=\(String(describing: self.gtype)), "
    desc += "createtime=\(String(describing: self.createtime)), "
    desc += "extend=\(String(describing: self.extend)), "
    desc += "extra=\(String(describing: self.extra))"
    return desc
  }

}

extension TimRoomBean : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(founder)
    hasher.combine(managers)
    hasher.combine(cover)
    hasher.combine(topic)
    hasher.combine(label)
    hasher.combine(gtype)
    hasher.combine(createtime)
    hasher.combine(extend)
    hasher.combine(extra)
  }

}

extension TimRoomBean : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["founder": 1, "managers": 2, "cover": 3, "topic": 4, "label": 5, "gtype": 6, "createtime": 7, "extend": 8, "extra": 9, ]
  }

  public static var structName: String { return "TimRoomBean" }

  public static func read(from proto: TProtocol) throws -> TimRoomBean {
    _ = try proto.readStructBegin()
    var founder: String?
    var managers: TList<String>?
    var cover: String?
    var topic: String?
    var label: String?
    var gtype: Int8?
    var createtime: Int64?
    var extend: TMap<String, String>?
    var extra: TMap<String, Data>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           founder = try String.read(from: proto)
        case (2, .list):            managers = try TList<String>.read(from: proto)
        case (3, .string):           cover = try String.read(from: proto)
        case (4, .string):           topic = try String.read(from: proto)
        case (5, .string):           label = try String.read(from: proto)
        case (6, .i8):            gtype = try Int8.read(from: proto)
        case (7, .i64):             createtime = try Int64.read(from: proto)
        case (8, .map):             extend = try TMap<String, String>.read(from: proto)
        case (9, .map):             extra = try TMap<String, Data>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimRoomBean(founder: founder, managers: managers, cover: cover, topic: topic, label: label, gtype: gtype, createtime: createtime, extend: extend, extra: extra)
  }

}



public func ==(lhs: TimAuth, rhs: TimAuth) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.pwd == rhs.pwd) &&
    (lhs.domain == rhs.domain) &&
    (lhs.resource == rhs.resource) &&
    (lhs.termtyp == rhs.termtyp) &&
    (lhs.token == rhs.token) &&
    (lhs.extend == rhs.extend)
}

extension TimAuth : CustomStringConvertible {

  public var description : String {
    var desc = "TimAuth("
    desc += "name=\(String(describing: self.name)), "
    desc += "pwd=\(String(describing: self.pwd)), "
    desc += "domain=\(String(describing: self.domain)), "
    desc += "resource=\(String(describing: self.resource)), "
    desc += "termtyp=\(String(describing: self.termtyp)), "
    desc += "token=\(String(describing: self.token)), "
    desc += "extend=\(String(describing: self.extend))"
    return desc
  }

}

extension TimAuth : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(name)
    hasher.combine(pwd)
    hasher.combine(domain)
    hasher.combine(resource)
    hasher.combine(termtyp)
    hasher.combine(token)
    hasher.combine(extend)
  }

}

extension TimAuth : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, "pwd": 2, "domain": 3, "resource": 4, "termtyp": 5, "token": 6, "extend": 7, ]
  }

  public static var structName: String { return "TimAuth" }

  public static func read(from proto: TProtocol) throws -> TimAuth {
    _ = try proto.readStructBegin()
    var name: String?
    var pwd: String?
    var domain: String?
    var resource: String?
    var termtyp: Int8?
    var token: Int64?
    var extend: TMap<String, String>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case (2, .string):           pwd = try String.read(from: proto)
        case (3, .string):           domain = try String.read(from: proto)
        case (4, .string):           resource = try String.read(from: proto)
        case (5, .i8):            termtyp = try Int8.read(from: proto)
        case (6, .i64):             token = try Int64.read(from: proto)
        case (7, .map):             extend = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimAuth(name: name, pwd: pwd, domain: domain, resource: resource, termtyp: termtyp, token: token, extend: extend)
  }

}



public func ==(lhs: TimPresence, rhs: TimPresence) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.offline == rhs.offline) &&
    (lhs.subStatus == rhs.subStatus) &&
    (lhs.fromTid == rhs.fromTid) &&
    (lhs.toTid == rhs.toTid) &&
    (lhs.toList == rhs.toList) &&
    (lhs.show == rhs.show) &&
    (lhs.status == rhs.status) &&
    (lhs.extend == rhs.extend) &&
    (lhs.extra == rhs.extra)
}

extension TimPresence : CustomStringConvertible {

  public var description : String {
    var desc = "TimPresence("
    desc += "id=\(String(describing: self.id)), "
    desc += "offline=\(String(describing: self.offline)), "
    desc += "subStatus=\(String(describing: self.subStatus)), "
    desc += "fromTid=\(String(describing: self.fromTid)), "
    desc += "toTid=\(String(describing: self.toTid)), "
    desc += "toList=\(String(describing: self.toList)), "
    desc += "show=\(String(describing: self.show)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "extend=\(String(describing: self.extend)), "
    desc += "extra=\(String(describing: self.extra))"
    return desc
  }

}

extension TimPresence : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(offline)
    hasher.combine(subStatus)
    hasher.combine(fromTid)
    hasher.combine(toTid)
    hasher.combine(toList)
    hasher.combine(show)
    hasher.combine(status)
    hasher.combine(extend)
    hasher.combine(extra)
  }

}

extension TimPresence : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "offline": 2, "subStatus": 3, "fromTid": 4, "toTid": 5, "toList": 6, "show": 7, "status": 8, "extend": 9, "extra": 10, ]
  }

  public static var structName: String { return "TimPresence" }

  public static func read(from proto: TProtocol) throws -> TimPresence {
    _ = try proto.readStructBegin()
    var id: Int64?
    var offline: Bool?
    var subStatus: Int8?
    var fromTid: Tid?
    var toTid: Tid?
    var toList: TList<String>?
    var show: Int16?
    var status: String?
    var extend: TMap<String, String>?
    var extra: TMap<String, Data>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .bool):            offline = try Bool.read(from: proto)
        case (3, .i8):            subStatus = try Int8.read(from: proto)
        case (4, .struct):           fromTid = try Tid.read(from: proto)
        case (5, .struct):           toTid = try Tid.read(from: proto)
        case (6, .list):            toList = try TList<String>.read(from: proto)
        case (7, .i16):             show = try Int16.read(from: proto)
        case (8, .string):           status = try String.read(from: proto)
        case (9, .map):             extend = try TMap<String, String>.read(from: proto)
        case (10, .map):             extra = try TMap<String, Data>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimPresence(id: id, offline: offline, subStatus: subStatus, fromTid: fromTid, toTid: toTid, toList: toList, show: show, status: status, extend: extend, extra: extra)
  }

}



public func ==(lhs: TimMessage, rhs: TimMessage) -> Bool {
  return
    (lhs.msType == rhs.msType) &&
    (lhs.odType == rhs.odType) &&
    (lhs.id == rhs.id) &&
    (lhs.mid == rhs.mid) &&
    (lhs.bnType == rhs.bnType) &&
    (lhs.fromTid == rhs.fromTid) &&
    (lhs.toTid == rhs.toTid) &&
    (lhs.roomTid == rhs.roomTid) &&
    (lhs.dataBinary == rhs.dataBinary) &&
    (lhs.dataString == rhs.dataString) &&
    (lhs.isOffline == rhs.isOffline) &&
    (lhs.timestamp == rhs.timestamp) &&
    (lhs.udtype == rhs.udtype) &&
    (lhs.udshow == rhs.udshow) &&
    (lhs.extend == rhs.extend) &&
    (lhs.extra == rhs.extra)
}

extension TimMessage : CustomStringConvertible {

  public var description : String {
    var desc = "TimMessage("
    desc += "msType=\(String(describing: self.msType)), "
    desc += "odType=\(String(describing: self.odType)), "
    desc += "id=\(String(describing: self.id)), "
    desc += "mid=\(String(describing: self.mid)), "
    desc += "bnType=\(String(describing: self.bnType)), "
    desc += "fromTid=\(String(describing: self.fromTid)), "
    desc += "toTid=\(String(describing: self.toTid)), "
    desc += "roomTid=\(String(describing: self.roomTid)), "
    desc += "dataBinary=\(String(describing: self.dataBinary)), "
    desc += "dataString=\(String(describing: self.dataString)), "
    desc += "isOffline=\(String(describing: self.isOffline)), "
    desc += "timestamp=\(String(describing: self.timestamp)), "
    desc += "udtype=\(String(describing: self.udtype)), "
    desc += "udshow=\(String(describing: self.udshow)), "
    desc += "extend=\(String(describing: self.extend)), "
    desc += "extra=\(String(describing: self.extra))"
    return desc
  }

}

extension TimMessage : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(msType)
    hasher.combine(odType)
    hasher.combine(id)
    hasher.combine(mid)
    hasher.combine(bnType)
    hasher.combine(fromTid)
    hasher.combine(toTid)
    hasher.combine(roomTid)
    hasher.combine(dataBinary)
    hasher.combine(dataString)
    hasher.combine(isOffline)
    hasher.combine(timestamp)
    hasher.combine(udtype)
    hasher.combine(udshow)
    hasher.combine(extend)
    hasher.combine(extra)
  }

}

extension TimMessage : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["msType": 1, "odType": 2, "id": 3, "mid": 4, "bnType": 5, "fromTid": 6, "toTid": 7, "roomTid": 8, "dataBinary": 9, "dataString": 10, "isOffline": 11, "timestamp": 12, "udtype": 13, "udshow": 14, "extend": 15, "extra": 16, ]
  }

  public static var structName: String { return "TimMessage" }

  public static func read(from proto: TProtocol) throws -> TimMessage {
    _ = try proto.readStructBegin()
    var msType: Int8!
    var odType: Int8!
    var id: Int64?
    var mid: Int64?
    var bnType: Int32?
    var fromTid: Tid?
    var toTid: Tid?
    var roomTid: Tid?
    var dataBinary: Data?
    var dataString: String?
    var isOffline: Bool?
    var timestamp: Int64?
    var udtype: Int16?
    var udshow: Int16?
    var extend: TMap<String, String>?
    var extra: TMap<String, Data>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i8):            msType = try Int8.read(from: proto)
        case (2, .i8):            odType = try Int8.read(from: proto)
        case (3, .i64):             id = try Int64.read(from: proto)
        case (4, .i64):             mid = try Int64.read(from: proto)
        case (5, .i32):             bnType = try Int32.read(from: proto)
        case (6, .struct):           fromTid = try Tid.read(from: proto)
        case (7, .struct):           toTid = try Tid.read(from: proto)
        case (8, .struct):           roomTid = try Tid.read(from: proto)
        case (9, .string):           dataBinary = try Data.read(from: proto)
        case (10, .string):           dataString = try String.read(from: proto)
        case (11, .bool):            isOffline = try Bool.read(from: proto)
        case (12, .i64):             timestamp = try Int64.read(from: proto)
        case (13, .i16):             udtype = try Int16.read(from: proto)
        case (14, .i16):             udshow = try Int16.read(from: proto)
        case (15, .map):             extend = try TMap<String, String>.read(from: proto)
        case (16, .map):             extra = try TMap<String, Data>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(msType, named: "msType")
    try proto.validateValue(odType, named: "odType")

    return TimMessage(msType: msType, odType: odType, id: id, mid: mid, bnType: bnType, fromTid: fromTid, toTid: toTid, roomTid: roomTid, dataBinary: dataBinary, dataString: dataString, isOffline: isOffline, timestamp: timestamp, udtype: udtype, udshow: udshow, extend: extend, extra: extra)
  }

}



public func ==(lhs: TimStream, rhs: TimStream) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.VNode == rhs.VNode) &&
    (lhs.dtype == rhs.dtype) &&
    (lhs.body == rhs.body) &&
    (lhs.fromNode == rhs.fromNode)
}

extension TimStream : CustomStringConvertible {

  public var description : String {
    var desc = "TimStream("
    desc += "id=\(String(describing: self.id)), "
    desc += "VNode=\(String(describing: self.VNode)), "
    desc += "dtype=\(String(describing: self.dtype)), "
    desc += "body=\(String(describing: self.body)), "
    desc += "fromNode=\(String(describing: self.fromNode))"
    return desc
  }

}

extension TimStream : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(VNode)
    hasher.combine(dtype)
    hasher.combine(body)
    hasher.combine(fromNode)
  }

}

extension TimStream : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "VNode": 2, "dtype": 3, "body": 4, "fromNode": 5, ]
  }

  public static var structName: String { return "TimStream" }

  public static func read(from proto: TProtocol) throws -> TimStream {
    _ = try proto.readStructBegin()
    var id: Int64!
    var VNode: String!
    var dtype: Int8?
    var body: Data?
    var fromNode: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .string):           VNode = try String.read(from: proto)
        case (3, .i8):            dtype = try Int8.read(from: proto)
        case (4, .string):           body = try Data.read(from: proto)
        case (5, .string):           fromNode = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(VNode, named: "VNode")
    try proto.validateValue(fromNode, named: "fromNode")

    return TimStream(id: id, VNode: VNode, dtype: dtype, body: body, fromNode: fromNode)
  }

}



public func ==(lhs: TimNodes, rhs: TimNodes) -> Bool {
  return
    (lhs.ntype == rhs.ntype) &&
    (lhs.nodelist == rhs.nodelist) &&
    (lhs.usermap == rhs.usermap) &&
    (lhs.roommap == rhs.roommap) &&
    (lhs.node == rhs.node)
}

extension TimNodes : CustomStringConvertible {

  public var description : String {
    var desc = "TimNodes("
    desc += "ntype=\(String(describing: self.ntype)), "
    desc += "nodelist=\(String(describing: self.nodelist)), "
    desc += "usermap=\(String(describing: self.usermap)), "
    desc += "roommap=\(String(describing: self.roommap)), "
    desc += "node=\(String(describing: self.node))"
    return desc
  }

}

extension TimNodes : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(ntype)
    hasher.combine(nodelist)
    hasher.combine(usermap)
    hasher.combine(roommap)
    hasher.combine(node)
  }

}

extension TimNodes : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["ntype": 1, "nodelist": 2, "usermap": 3, "roommap": 4, "node": 5, ]
  }

  public static var structName: String { return "TimNodes" }

  public static func read(from proto: TProtocol) throws -> TimNodes {
    _ = try proto.readStructBegin()
    var ntype: Int32!
    var nodelist: TList<String>?
    var usermap: TMap<String, TimUserBean>?
    var roommap: TMap<String, TimRoomBean>?
    var node: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             ntype = try Int32.read(from: proto)
        case (2, .list):            nodelist = try TList<String>.read(from: proto)
        case (3, .map):             usermap = try TMap<String, TimUserBean>.read(from: proto)
        case (4, .map):             roommap = try TMap<String, TimRoomBean>.read(from: proto)
        case (5, .string):           node = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ntype, named: "ntype")

    return TimNodes(ntype: ntype, nodelist: nodelist, usermap: usermap, roommap: roommap, node: node)
  }

}



public func ==(lhs: TimMessageList, rhs: TimMessageList) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.messageList == rhs.messageList)
}

extension TimMessageList : CustomStringConvertible {

  public var description : String {
    var desc = "TimMessageList("
    desc += "id=\(String(describing: self.id)), "
    desc += "messageList=\(String(describing: self.messageList))"
    return desc
  }

}

extension TimMessageList : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(messageList)
  }

}

extension TimMessageList : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "messageList": 2, ]
  }

  public static var structName: String { return "TimMessageList" }

  public static func read(from proto: TProtocol) throws -> TimMessageList {
    _ = try proto.readStructBegin()
    var id: Int64?
    var messageList: TList<TimMessage>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .list):            messageList = try TList<TimMessage>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TimMessageList(id: id, messageList: messageList)
  }

}



