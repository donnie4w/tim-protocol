/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "stub_types.h"
#include <thrift/c_glib/thrift.h>

enum _TimErrorProperties
{
  PROP_TIM_ERROR_0,
  PROP_TIM_ERROR_CODE,
  PROP_TIM_ERROR_INFO
};

/* reads a tim_error object */
static gint32
tim_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimError * this_object = TIM_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->info != NULL)
          {
            g_free(this_object->info);
            this_object->info = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->info, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_info = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimError * this_object = TIM_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_code == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_info == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "info", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->info, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_error_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimError *self = TIM_ERROR (object);

  switch (property_id)
  {
    case PROP_TIM_ERROR_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_TIM_ERROR_INFO:
      if (self->info != NULL)
        g_free (self->info);
      self->info = g_value_dup_string (value);
      self->__isset_info = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_error_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimError *self = TIM_ERROR (object);

  switch (property_id)
  {
    case PROP_TIM_ERROR_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_TIM_ERROR_INFO:
      g_value_set_string (value, self->info);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_error_instance_init (TimError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->info = NULL;
  object->__isset_info = FALSE;
}

static void 
tim_error_finalize (GObject *object)
{
  TimError *tobject = TIM_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->info != NULL)
  {
    g_free(tobject->info);
    tobject->info = NULL;
  }
}

static void
tim_error_class_init (TimErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_error_read;
  struct_class->write = tim_error_write;

  gobject_class->finalize = tim_error_finalize;
  gobject_class->get_property = tim_error_get_property;
  gobject_class->set_property = tim_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ERROR_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ERROR_INFO,
     g_param_spec_string ("info",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimError),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimErrorType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimAckProperties
{
  PROP_TIM_ACK_0,
  PROP_TIM_ACK_OK,
  PROP_TIM_ACK_TIM_TYPE,
  PROP_TIM_ACK_ERROR,
  PROP_TIM_ACK_T,
  PROP_TIM_ACK_N,
  PROP_TIM_ACK_T2,
  PROP_TIM_ACK_N2
};

/* reads a tim_ack object */
static gint32
tim_ack_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimAck * this_object = TIM_ACK(object);
  gboolean isset_ok = FALSE;
  gboolean isset_timType = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ok, error)) < 0)
            return -1;
          xfer += ret;
          isset_ok = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->timType, error)) < 0)
            return -1;
          xfer += ret;
          isset_timType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->t, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_t = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->n != NULL)
          {
            g_free(this_object->n);
            this_object->n = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->n, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_n = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->t2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_t2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->n2 != NULL)
          {
            g_free(this_object->n2);
            this_object->n2 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->n2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_n2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_ok)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_timType)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_ack_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimAck * this_object = TIM_ACK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimAck", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ok", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->ok, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timType", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->timType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_t == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "t", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->t, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_n == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "n", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->n, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_t2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "t2", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->t2, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_n2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "n2", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->n2, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_ack_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  TimAck *self = TIM_ACK (object);

  switch (property_id)
  {
    case PROP_TIM_ACK_OK:
      self->ok = g_value_get_boolean (value);
      break;

    case PROP_TIM_ACK_TIM_TYPE:
      self->timType = g_value_get_int (value);
      break;

    case PROP_TIM_ACK_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_ACK_T:
      self->t = g_value_get_int64 (value);
      self->__isset_t = TRUE;
      break;

    case PROP_TIM_ACK_N:
      if (self->n != NULL)
        g_free (self->n);
      self->n = g_value_dup_string (value);
      self->__isset_n = TRUE;
      break;

    case PROP_TIM_ACK_T2:
      self->t2 = g_value_get_int64 (value);
      self->__isset_t2 = TRUE;
      break;

    case PROP_TIM_ACK_N2:
      if (self->n2 != NULL)
        g_free (self->n2);
      self->n2 = g_value_dup_string (value);
      self->__isset_n2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_ack_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  TimAck *self = TIM_ACK (object);

  switch (property_id)
  {
    case PROP_TIM_ACK_OK:
      g_value_set_boolean (value, self->ok);
      break;

    case PROP_TIM_ACK_TIM_TYPE:
      g_value_set_int (value, self->timType);
      break;

    case PROP_TIM_ACK_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_ACK_T:
      g_value_set_int64 (value, self->t);
      break;

    case PROP_TIM_ACK_N:
      g_value_set_string (value, self->n);
      break;

    case PROP_TIM_ACK_T2:
      g_value_set_int64 (value, self->t2);
      break;

    case PROP_TIM_ACK_N2:
      g_value_set_string (value, self->n2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_ack_instance_init (TimAck * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ok = 0;
  object->timType = 0;
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->t = 0;
  object->__isset_t = FALSE;
  object->n = NULL;
  object->__isset_n = FALSE;
  object->t2 = 0;
  object->__isset_t2 = FALSE;
  object->n2 = NULL;
  object->__isset_n2 = FALSE;
}

static void 
tim_ack_finalize (GObject *object)
{
  TimAck *tobject = TIM_ACK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->n != NULL)
  {
    g_free(tobject->n);
    tobject->n = NULL;
  }
  if (tobject->n2 != NULL)
  {
    g_free(tobject->n2);
    tobject->n2 = NULL;
  }
}

static void
tim_ack_class_init (TimAckClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_ack_read;
  struct_class->write = tim_ack_write;

  gobject_class->finalize = tim_ack_finalize;
  gobject_class->get_property = tim_ack_get_property;
  gobject_class->set_property = tim_ack_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_OK,
     g_param_spec_boolean ("ok",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_TIM_TYPE,
     g_param_spec_int ("timType",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_T,
     g_param_spec_int64 ("t",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_N,
     g_param_spec_string ("n",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_T2,
     g_param_spec_int64 ("t2",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_N2,
     g_param_spec_string ("n2",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_ack_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimAckClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_ack_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimAck),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_ack_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimAckType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimReqProperties
{
  PROP_TIM_REQ_0,
  PROP_TIM_REQ_RTYPE,
  PROP_TIM_REQ_NODE,
  PROP_TIM_REQ_NODE2,
  PROP_TIM_REQ_REQ_INT,
  PROP_TIM_REQ_REQ_INT2,
  PROP_TIM_REQ_REQ_STR,
  PROP_TIM_REQ_REQ_STR2
};

/* reads a tim_req object */
static gint32
tim_req_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimReq * this_object = TIM_REQ(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->rtype, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rtype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->node != NULL)
          {
            g_free(this_object->node);
            this_object->node = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->node, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->node2 != NULL)
          {
            g_free(this_object->node2);
            this_object->node2 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->node2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_node2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->reqInt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqInt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->reqInt2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqInt2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->reqStr != NULL)
          {
            g_free(this_object->reqStr);
            this_object->reqStr = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->reqStr, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqStr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->reqStr2 != NULL)
          {
            g_free(this_object->reqStr2);
            this_object->reqStr2 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->reqStr2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqStr2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_req_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimReq * this_object = TIM_REQ(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimReq", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_rtype == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rtype", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->rtype, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->node, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node2", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->node2, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqInt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqInt", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->reqInt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqInt2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqInt2", T_I64, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->reqInt2, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqStr == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqStr", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->reqStr, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqStr2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqStr2", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->reqStr2, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_req_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  TimReq *self = TIM_REQ (object);

  switch (property_id)
  {
    case PROP_TIM_REQ_RTYPE:
      self->rtype = g_value_get_int (value);
      self->__isset_rtype = TRUE;
      break;

    case PROP_TIM_REQ_NODE:
      if (self->node != NULL)
        g_free (self->node);
      self->node = g_value_dup_string (value);
      self->__isset_node = TRUE;
      break;

    case PROP_TIM_REQ_NODE2:
      if (self->node2 != NULL)
        g_free (self->node2);
      self->node2 = g_value_dup_string (value);
      self->__isset_node2 = TRUE;
      break;

    case PROP_TIM_REQ_REQ_INT:
      self->reqInt = g_value_get_int64 (value);
      self->__isset_reqInt = TRUE;
      break;

    case PROP_TIM_REQ_REQ_INT2:
      self->reqInt2 = g_value_get_int64 (value);
      self->__isset_reqInt2 = TRUE;
      break;

    case PROP_TIM_REQ_REQ_STR:
      if (self->reqStr != NULL)
        g_free (self->reqStr);
      self->reqStr = g_value_dup_string (value);
      self->__isset_reqStr = TRUE;
      break;

    case PROP_TIM_REQ_REQ_STR2:
      if (self->reqStr2 != NULL)
        g_free (self->reqStr2);
      self->reqStr2 = g_value_dup_string (value);
      self->__isset_reqStr2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_req_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  TimReq *self = TIM_REQ (object);

  switch (property_id)
  {
    case PROP_TIM_REQ_RTYPE:
      g_value_set_int (value, self->rtype);
      break;

    case PROP_TIM_REQ_NODE:
      g_value_set_string (value, self->node);
      break;

    case PROP_TIM_REQ_NODE2:
      g_value_set_string (value, self->node2);
      break;

    case PROP_TIM_REQ_REQ_INT:
      g_value_set_int64 (value, self->reqInt);
      break;

    case PROP_TIM_REQ_REQ_INT2:
      g_value_set_int64 (value, self->reqInt2);
      break;

    case PROP_TIM_REQ_REQ_STR:
      g_value_set_string (value, self->reqStr);
      break;

    case PROP_TIM_REQ_REQ_STR2:
      g_value_set_string (value, self->reqStr2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_req_instance_init (TimReq * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rtype = 0;
  object->__isset_rtype = FALSE;
  object->node = NULL;
  object->__isset_node = FALSE;
  object->node2 = NULL;
  object->__isset_node2 = FALSE;
  object->reqInt = 0;
  object->__isset_reqInt = FALSE;
  object->reqInt2 = 0;
  object->__isset_reqInt2 = FALSE;
  object->reqStr = NULL;
  object->__isset_reqStr = FALSE;
  object->reqStr2 = NULL;
  object->__isset_reqStr2 = FALSE;
}

static void 
tim_req_finalize (GObject *object)
{
  TimReq *tobject = TIM_REQ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->node != NULL)
  {
    g_free(tobject->node);
    tobject->node = NULL;
  }
  if (tobject->node2 != NULL)
  {
    g_free(tobject->node2);
    tobject->node2 = NULL;
  }
  if (tobject->reqStr != NULL)
  {
    g_free(tobject->reqStr);
    tobject->reqStr = NULL;
  }
  if (tobject->reqStr2 != NULL)
  {
    g_free(tobject->reqStr2);
    tobject->reqStr2 = NULL;
  }
}

static void
tim_req_class_init (TimReqClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_req_read;
  struct_class->write = tim_req_write;

  gobject_class->finalize = tim_req_finalize;
  gobject_class->get_property = tim_req_get_property;
  gobject_class->set_property = tim_req_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_RTYPE,
     g_param_spec_int ("rtype",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_NODE,
     g_param_spec_string ("node",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_NODE2,
     g_param_spec_string ("node2",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_REQ_INT,
     g_param_spec_int64 ("reqInt",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_REQ_INT2,
     g_param_spec_int64 ("reqInt2",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_REQ_STR,
     g_param_spec_string ("reqStr",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REQ_REQ_STR2,
     g_param_spec_string ("reqStr2",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_req_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimReqClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_req_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimReq),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_req_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimReqType",
                                   &type_info, 0);
  }

  return type;
}

enum _TidProperties
{
  PROP_TID_0,
  PROP_TID_NODE,
  PROP_TID_DOMAIN,
  PROP_TID_RESOURCE,
  PROP_TID_TERMTYP,
  PROP_TID_EXTEND
};

/* reads a tid object */
static gint32
tid_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Tid * this_object = TID(object);
  gboolean isset_node = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->node != NULL)
          {
            g_free(this_object->node);
            this_object->node = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->node, error)) < 0)
            return -1;
          xfer += ret;
          isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->domain != NULL)
          {
            g_free(this_object->domain);
            this_object->domain = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->domain, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_domain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->resource != NULL)
          {
            g_free(this_object->resource);
            this_object->resource = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->resource, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_resource = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->termtyp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_termtyp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key0 = NULL;
              gchar * val1 = NULL;
              if (key0 != NULL)
              {
                g_free(key0);
                key0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key0, error)) < 0)
                return -1;
              xfer += ret;
              if (val1 != NULL)
              {
                g_free(val1);
                val1 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val1, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key0)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_node)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tid_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Tid * this_object = TID(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Tid", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->node, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_domain == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "domain", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->domain, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_resource == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "resource", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->resource, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_termtyp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "termtyp", T_BYTE, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->termtyp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key2 = NULL;
      gchar * val3 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key2 = keys[i];
        val3 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key2);

        if ((ret = thrift_protocol_write_string (protocol,  key2, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val3, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tid_set_property (GObject *object,
                  guint property_id,
                  const GValue *value,
                  GParamSpec *pspec)
{
  Tid *self = TID (object);

  switch (property_id)
  {
    case PROP_TID_NODE:
      if (self->node != NULL)
        g_free (self->node);
      self->node = g_value_dup_string (value);
      break;

    case PROP_TID_DOMAIN:
      if (self->domain != NULL)
        g_free (self->domain);
      self->domain = g_value_dup_string (value);
      self->__isset_domain = TRUE;
      break;

    case PROP_TID_RESOURCE:
      if (self->resource != NULL)
        g_free (self->resource);
      self->resource = g_value_dup_string (value);
      self->__isset_resource = TRUE;
      break;

    case PROP_TID_TERMTYP:
      self->termtyp = g_value_get_int (value);
      self->__isset_termtyp = TRUE;
      break;

    case PROP_TID_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tid_get_property (GObject *object,
                  guint property_id,
                  GValue *value,
                  GParamSpec *pspec)
{
  Tid *self = TID (object);

  switch (property_id)
  {
    case PROP_TID_NODE:
      g_value_set_string (value, self->node);
      break;

    case PROP_TID_DOMAIN:
      g_value_set_string (value, self->domain);
      break;

    case PROP_TID_RESOURCE:
      g_value_set_string (value, self->resource);
      break;

    case PROP_TID_TERMTYP:
      g_value_set_int (value, self->termtyp);
      break;

    case PROP_TID_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tid_instance_init (Tid * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->node = NULL;
  object->domain = NULL;
  object->__isset_domain = FALSE;
  object->resource = NULL;
  object->__isset_resource = FALSE;
  object->termtyp = 0;
  object->__isset_termtyp = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
}

static void 
tid_finalize (GObject *object)
{
  Tid *tobject = TID (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->node != NULL)
  {
    g_free(tobject->node);
    tobject->node = NULL;
  }
  if (tobject->domain != NULL)
  {
    g_free(tobject->domain);
    tobject->domain = NULL;
  }
  if (tobject->resource != NULL)
  {
    g_free(tobject->resource);
    tobject->resource = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
}

static void
tid_class_init (TidClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tid_read;
  struct_class->write = tid_write;

  gobject_class->finalize = tid_finalize;
  gobject_class->get_property = tid_get_property;
  gobject_class->set_property = tid_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TID_NODE,
     g_param_spec_string ("node",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_DOMAIN,
     g_param_spec_string ("domain",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_RESOURCE,
     g_param_spec_string ("resource",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_TERMTYP,
     g_param_spec_int ("termtyp",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tid_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TidClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tid_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Tid),
      0, /* n_preallocs */
      (GInstanceInitFunc) tid_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TidType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimUserBeanProperties
{
  PROP_TIM_USER_BEAN_0,
  PROP_TIM_USER_BEAN_NAME,
  PROP_TIM_USER_BEAN_NICK_NAME,
  PROP_TIM_USER_BEAN_BRITHDAY,
  PROP_TIM_USER_BEAN_GENDER,
  PROP_TIM_USER_BEAN_COVER,
  PROP_TIM_USER_BEAN_AREA,
  PROP_TIM_USER_BEAN_CREATETIME,
  PROP_TIM_USER_BEAN_PHOTO_TID_ALBUM,
  PROP_TIM_USER_BEAN_EXTEND,
  PROP_TIM_USER_BEAN_EXTRA
};

/* reads a tim_user_bean object */
static gint32
tim_user_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimUserBean * this_object = TIM_USER_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->nickName != NULL)
          {
            g_free(this_object->nickName);
            this_object->nickName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nickName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nickName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->brithday != NULL)
          {
            g_free(this_object->brithday);
            this_object->brithday = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->brithday, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_brithday = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->gender, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_gender = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->cover != NULL)
          {
            g_free(this_object->cover);
            this_object->cover = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cover, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cover = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->area != NULL)
          {
            g_free(this_object->area);
            this_object->area = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->area, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_area = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createtime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createtime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem4 = NULL;
              if (_elem4 != NULL)
              {
                g_free(_elem4);
                _elem4 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->photoTidAlbum, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_photoTidAlbum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key5 = NULL;
              gchar * val6 = NULL;
              if (key5 != NULL)
              {
                g_free(key5);
                key5 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key5, error)) < 0)
                return -1;
              xfer += ret;
              if (val6 != NULL)
              {
                g_free(val6);
                val6 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val6, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key5)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key5, (gpointer) val6);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key7 = NULL;
              GByteArray * val8 = NULL;
              if (key7 != NULL)
              {
                g_free(key7);
                key7 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key7, error)) < 0)
                return -1;
              xfer += ret;
              if (val8 != NULL)
              {
                g_free(val8);
                val8 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val8 = g_byte_array_new();
              g_byte_array_append (val8, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->extra && key7)
                g_hash_table_insert ((GHashTable *)this_object->extra, (gpointer) key7, (gpointer) val8);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extra = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_user_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimUserBean * this_object = TIM_USER_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimUserBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_nickName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "nickName", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->nickName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_brithday == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "brithday", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->brithday, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_gender == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "gender", T_BYTE, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->gender, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cover == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cover", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->cover, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_area == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "area", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->area, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createtime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createtime", T_I64, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createtime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_photoTidAlbum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "photoTidAlbum", T_LIST, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i9;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->photoTidAlbum ? this_object->photoTidAlbum->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i9 = 0; i9 < (this_object->photoTidAlbum ? this_object->photoTidAlbum->len : 0); i9++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->photoTidAlbum, i9)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key10 = NULL;
      gchar * val11 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key10 = keys[i];
        val11 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key10);

        if ((ret = thrift_protocol_write_string (protocol,  key10, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val11, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extra == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extra", T_MAP, 11, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key12 = NULL;
      GByteArray * val13 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extra ? (gint32) g_hash_table_size ((GHashTable *) this_object->extra) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extra)
        g_hash_table_foreach ((GHashTable *) this_object->extra, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key12 = keys[i];
        val13 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->extra), (gpointer) key12);

        if ((ret = thrift_protocol_write_string (protocol,  key12, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val13 ? ((GByteArray *)  val13)->data : NULL,  val13 ? ((GByteArray *)  val13)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_user_bean_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TimUserBean *self = TIM_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_USER_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_TIM_USER_BEAN_NICK_NAME:
      if (self->nickName != NULL)
        g_free (self->nickName);
      self->nickName = g_value_dup_string (value);
      self->__isset_nickName = TRUE;
      break;

    case PROP_TIM_USER_BEAN_BRITHDAY:
      if (self->brithday != NULL)
        g_free (self->brithday);
      self->brithday = g_value_dup_string (value);
      self->__isset_brithday = TRUE;
      break;

    case PROP_TIM_USER_BEAN_GENDER:
      self->gender = g_value_get_int (value);
      self->__isset_gender = TRUE;
      break;

    case PROP_TIM_USER_BEAN_COVER:
      if (self->cover != NULL)
        g_free (self->cover);
      self->cover = g_value_dup_string (value);
      self->__isset_cover = TRUE;
      break;

    case PROP_TIM_USER_BEAN_AREA:
      if (self->area != NULL)
        g_free (self->area);
      self->area = g_value_dup_string (value);
      self->__isset_area = TRUE;
      break;

    case PROP_TIM_USER_BEAN_CREATETIME:
      self->createtime = g_value_get_int64 (value);
      self->__isset_createtime = TRUE;
      break;

    case PROP_TIM_USER_BEAN_PHOTO_TID_ALBUM:
      if (self->photoTidAlbum != NULL)
        g_ptr_array_unref (self->photoTidAlbum);
      self->photoTidAlbum = g_value_dup_boxed (value);
      self->__isset_photoTidAlbum = TRUE;
      break;

    case PROP_TIM_USER_BEAN_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    case PROP_TIM_USER_BEAN_EXTRA:
      if (self->extra != NULL)
        g_hash_table_unref (self->extra);
      self->extra = g_value_dup_boxed (value);
      self->__isset_extra = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_user_bean_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TimUserBean *self = TIM_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_USER_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_TIM_USER_BEAN_NICK_NAME:
      g_value_set_string (value, self->nickName);
      break;

    case PROP_TIM_USER_BEAN_BRITHDAY:
      g_value_set_string (value, self->brithday);
      break;

    case PROP_TIM_USER_BEAN_GENDER:
      g_value_set_int (value, self->gender);
      break;

    case PROP_TIM_USER_BEAN_COVER:
      g_value_set_string (value, self->cover);
      break;

    case PROP_TIM_USER_BEAN_AREA:
      g_value_set_string (value, self->area);
      break;

    case PROP_TIM_USER_BEAN_CREATETIME:
      g_value_set_int64 (value, self->createtime);
      break;

    case PROP_TIM_USER_BEAN_PHOTO_TID_ALBUM:
      g_value_set_boxed (value, self->photoTidAlbum);
      break;

    case PROP_TIM_USER_BEAN_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    case PROP_TIM_USER_BEAN_EXTRA:
      g_value_set_boxed (value, self->extra);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_user_bean_instance_init (TimUserBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->nickName = NULL;
  object->__isset_nickName = FALSE;
  object->brithday = NULL;
  object->__isset_brithday = FALSE;
  object->gender = 0;
  object->__isset_gender = FALSE;
  object->cover = NULL;
  object->__isset_cover = FALSE;
  object->area = NULL;
  object->__isset_area = FALSE;
  object->createtime = 0;
  object->__isset_createtime = FALSE;
  object->photoTidAlbum = g_ptr_array_new_with_free_func (g_free);
  object->__isset_photoTidAlbum = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
  object->extra = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_extra = FALSE;
}

static void 
tim_user_bean_finalize (GObject *object)
{
  TimUserBean *tobject = TIM_USER_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->nickName != NULL)
  {
    g_free(tobject->nickName);
    tobject->nickName = NULL;
  }
  if (tobject->brithday != NULL)
  {
    g_free(tobject->brithday);
    tobject->brithday = NULL;
  }
  if (tobject->cover != NULL)
  {
    g_free(tobject->cover);
    tobject->cover = NULL;
  }
  if (tobject->area != NULL)
  {
    g_free(tobject->area);
    tobject->area = NULL;
  }
  if (tobject->photoTidAlbum != NULL)
  {
    g_ptr_array_unref (tobject->photoTidAlbum);
    tobject->photoTidAlbum = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
  if (tobject->extra != NULL)
  {
    g_hash_table_destroy (tobject->extra);
    tobject->extra = NULL;
  }
}

static void
tim_user_bean_class_init (TimUserBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_user_bean_read;
  struct_class->write = tim_user_bean_write;

  gobject_class->finalize = tim_user_bean_finalize;
  gobject_class->get_property = tim_user_bean_get_property;
  gobject_class->set_property = tim_user_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_NICK_NAME,
     g_param_spec_string ("nickName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_BRITHDAY,
     g_param_spec_string ("brithday",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_GENDER,
     g_param_spec_int ("gender",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_COVER,
     g_param_spec_string ("cover",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_AREA,
     g_param_spec_string ("area",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_CREATETIME,
     g_param_spec_int64 ("createtime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_PHOTO_TID_ALBUM,
     g_param_spec_boxed ("photoTidAlbum",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_EXTRA,
     g_param_spec_boxed ("extra",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_user_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimUserBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_user_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimUserBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_user_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimUserBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimRoomBeanProperties
{
  PROP_TIM_ROOM_BEAN_0,
  PROP_TIM_ROOM_BEAN_FOUNDER,
  PROP_TIM_ROOM_BEAN_MANAGERS,
  PROP_TIM_ROOM_BEAN_COVER,
  PROP_TIM_ROOM_BEAN_TOPIC,
  PROP_TIM_ROOM_BEAN_LABEL,
  PROP_TIM_ROOM_BEAN_GTYPE,
  PROP_TIM_ROOM_BEAN_KIND,
  PROP_TIM_ROOM_BEAN_CREATETIME,
  PROP_TIM_ROOM_BEAN_EXTEND,
  PROP_TIM_ROOM_BEAN_EXTRA
};

/* reads a tim_room_bean object */
static gint32
tim_room_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimRoomBean * this_object = TIM_ROOM_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->founder != NULL)
          {
            g_free(this_object->founder);
            this_object->founder = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->founder, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_founder = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem14 = NULL;
              if (_elem14 != NULL)
              {
                g_free(_elem14);
                _elem14 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem14, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->managers, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_managers = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->cover != NULL)
          {
            g_free(this_object->cover);
            this_object->cover = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cover, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cover = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->label != NULL)
          {
            g_free(this_object->label);
            this_object->label = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->gtype, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_gtype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->kind, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_kind = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createtime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createtime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key15 = NULL;
              gchar * val16 = NULL;
              if (key15 != NULL)
              {
                g_free(key15);
                key15 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key15, error)) < 0)
                return -1;
              xfer += ret;
              if (val16 != NULL)
              {
                g_free(val16);
                val16 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val16, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key15)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key15, (gpointer) val16);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key17 = NULL;
              GByteArray * val18 = NULL;
              if (key17 != NULL)
              {
                g_free(key17);
                key17 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key17, error)) < 0)
                return -1;
              xfer += ret;
              if (val18 != NULL)
              {
                g_free(val18);
                val18 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val18 = g_byte_array_new();
              g_byte_array_append (val18, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->extra && key17)
                g_hash_table_insert ((GHashTable *)this_object->extra, (gpointer) key17, (gpointer) val18);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extra = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_room_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimRoomBean * this_object = TIM_ROOM_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimRoomBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_founder == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "founder", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->founder, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_managers == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "managers", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i19;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->managers ? this_object->managers->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i19 = 0; i19 < (this_object->managers ? this_object->managers->len : 0); i19++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->managers, i19)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cover == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cover", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->cover, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_topic == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_label == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "label", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->label, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_gtype == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "gtype", T_BYTE, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->gtype, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_kind == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "kind", T_I64, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->kind, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createtime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createtime", T_I64, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createtime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key20 = NULL;
      gchar * val21 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key20 = keys[i];
        val21 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key20);

        if ((ret = thrift_protocol_write_string (protocol,  key20, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val21, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extra == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extra", T_MAP, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key22 = NULL;
      GByteArray * val23 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extra ? (gint32) g_hash_table_size ((GHashTable *) this_object->extra) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extra)
        g_hash_table_foreach ((GHashTable *) this_object->extra, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key22 = keys[i];
        val23 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->extra), (gpointer) key22);

        if ((ret = thrift_protocol_write_string (protocol,  key22, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val23 ? ((GByteArray *)  val23)->data : NULL,  val23 ? ((GByteArray *)  val23)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_room_bean_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TimRoomBean *self = TIM_ROOM_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_ROOM_BEAN_FOUNDER:
      if (self->founder != NULL)
        g_free (self->founder);
      self->founder = g_value_dup_string (value);
      self->__isset_founder = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_MANAGERS:
      if (self->managers != NULL)
        g_ptr_array_unref (self->managers);
      self->managers = g_value_dup_boxed (value);
      self->__isset_managers = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_COVER:
      if (self->cover != NULL)
        g_free (self->cover);
      self->cover = g_value_dup_string (value);
      self->__isset_cover = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      self->__isset_topic = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_LABEL:
      if (self->label != NULL)
        g_free (self->label);
      self->label = g_value_dup_string (value);
      self->__isset_label = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_GTYPE:
      self->gtype = g_value_get_int (value);
      self->__isset_gtype = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_KIND:
      self->kind = g_value_get_int64 (value);
      self->__isset_kind = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_CREATETIME:
      self->createtime = g_value_get_int64 (value);
      self->__isset_createtime = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    case PROP_TIM_ROOM_BEAN_EXTRA:
      if (self->extra != NULL)
        g_hash_table_unref (self->extra);
      self->extra = g_value_dup_boxed (value);
      self->__isset_extra = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_room_bean_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TimRoomBean *self = TIM_ROOM_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_ROOM_BEAN_FOUNDER:
      g_value_set_string (value, self->founder);
      break;

    case PROP_TIM_ROOM_BEAN_MANAGERS:
      g_value_set_boxed (value, self->managers);
      break;

    case PROP_TIM_ROOM_BEAN_COVER:
      g_value_set_string (value, self->cover);
      break;

    case PROP_TIM_ROOM_BEAN_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_TIM_ROOM_BEAN_LABEL:
      g_value_set_string (value, self->label);
      break;

    case PROP_TIM_ROOM_BEAN_GTYPE:
      g_value_set_int (value, self->gtype);
      break;

    case PROP_TIM_ROOM_BEAN_KIND:
      g_value_set_int64 (value, self->kind);
      break;

    case PROP_TIM_ROOM_BEAN_CREATETIME:
      g_value_set_int64 (value, self->createtime);
      break;

    case PROP_TIM_ROOM_BEAN_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    case PROP_TIM_ROOM_BEAN_EXTRA:
      g_value_set_boxed (value, self->extra);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_room_bean_instance_init (TimRoomBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->founder = NULL;
  object->__isset_founder = FALSE;
  object->managers = g_ptr_array_new_with_free_func (g_free);
  object->__isset_managers = FALSE;
  object->cover = NULL;
  object->__isset_cover = FALSE;
  object->topic = NULL;
  object->__isset_topic = FALSE;
  object->label = NULL;
  object->__isset_label = FALSE;
  object->gtype = 0;
  object->__isset_gtype = FALSE;
  object->kind = 0;
  object->__isset_kind = FALSE;
  object->createtime = 0;
  object->__isset_createtime = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
  object->extra = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_extra = FALSE;
}

static void 
tim_room_bean_finalize (GObject *object)
{
  TimRoomBean *tobject = TIM_ROOM_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->founder != NULL)
  {
    g_free(tobject->founder);
    tobject->founder = NULL;
  }
  if (tobject->managers != NULL)
  {
    g_ptr_array_unref (tobject->managers);
    tobject->managers = NULL;
  }
  if (tobject->cover != NULL)
  {
    g_free(tobject->cover);
    tobject->cover = NULL;
  }
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->label != NULL)
  {
    g_free(tobject->label);
    tobject->label = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
  if (tobject->extra != NULL)
  {
    g_hash_table_destroy (tobject->extra);
    tobject->extra = NULL;
  }
}

static void
tim_room_bean_class_init (TimRoomBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_room_bean_read;
  struct_class->write = tim_room_bean_write;

  gobject_class->finalize = tim_room_bean_finalize;
  gobject_class->get_property = tim_room_bean_get_property;
  gobject_class->set_property = tim_room_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_FOUNDER,
     g_param_spec_string ("founder",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_MANAGERS,
     g_param_spec_boxed ("managers",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_COVER,
     g_param_spec_string ("cover",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_LABEL,
     g_param_spec_string ("label",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_GTYPE,
     g_param_spec_int ("gtype",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_KIND,
     g_param_spec_int64 ("kind",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_CREATETIME,
     g_param_spec_int64 ("createtime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_BEAN_EXTRA,
     g_param_spec_boxed ("extra",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_room_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimRoomBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_room_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimRoomBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_room_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimRoomBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimAuthProperties
{
  PROP_TIM_AUTH_0,
  PROP_TIM_AUTH_NAME,
  PROP_TIM_AUTH_PWD,
  PROP_TIM_AUTH_DOMAIN,
  PROP_TIM_AUTH_RESOURCE,
  PROP_TIM_AUTH_TERMTYP,
  PROP_TIM_AUTH_TOKEN,
  PROP_TIM_AUTH_EXTEND
};

/* reads a tim_auth object */
static gint32
tim_auth_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimAuth * this_object = TIM_AUTH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pwd != NULL)
          {
            g_free(this_object->pwd);
            this_object->pwd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pwd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pwd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->domain != NULL)
          {
            g_free(this_object->domain);
            this_object->domain = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->domain, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_domain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->resource != NULL)
          {
            g_free(this_object->resource);
            this_object->resource = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->resource, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_resource = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->termtyp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_termtyp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->token, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key24 = NULL;
              gchar * val25 = NULL;
              if (key24 != NULL)
              {
                g_free(key24);
                key24 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key24, error)) < 0)
                return -1;
              xfer += ret;
              if (val25 != NULL)
              {
                g_free(val25);
                val25 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val25, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key24)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key24, (gpointer) val25);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_auth_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimAuth * this_object = TIM_AUTH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimAuth", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_pwd == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pwd", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->pwd, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_domain == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "domain", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->domain, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_resource == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "resource", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->resource, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_termtyp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "termtyp", T_BYTE, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->termtyp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_token == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->token, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key26 = NULL;
      gchar * val27 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key26 = keys[i];
        val27 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key26);

        if ((ret = thrift_protocol_write_string (protocol,  key26, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val27, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_auth_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimAuth *self = TIM_AUTH (object);

  switch (property_id)
  {
    case PROP_TIM_AUTH_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_TIM_AUTH_PWD:
      if (self->pwd != NULL)
        g_free (self->pwd);
      self->pwd = g_value_dup_string (value);
      self->__isset_pwd = TRUE;
      break;

    case PROP_TIM_AUTH_DOMAIN:
      if (self->domain != NULL)
        g_free (self->domain);
      self->domain = g_value_dup_string (value);
      self->__isset_domain = TRUE;
      break;

    case PROP_TIM_AUTH_RESOURCE:
      if (self->resource != NULL)
        g_free (self->resource);
      self->resource = g_value_dup_string (value);
      self->__isset_resource = TRUE;
      break;

    case PROP_TIM_AUTH_TERMTYP:
      self->termtyp = g_value_get_int (value);
      self->__isset_termtyp = TRUE;
      break;

    case PROP_TIM_AUTH_TOKEN:
      self->token = g_value_get_int64 (value);
      self->__isset_token = TRUE;
      break;

    case PROP_TIM_AUTH_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_auth_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimAuth *self = TIM_AUTH (object);

  switch (property_id)
  {
    case PROP_TIM_AUTH_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_TIM_AUTH_PWD:
      g_value_set_string (value, self->pwd);
      break;

    case PROP_TIM_AUTH_DOMAIN:
      g_value_set_string (value, self->domain);
      break;

    case PROP_TIM_AUTH_RESOURCE:
      g_value_set_string (value, self->resource);
      break;

    case PROP_TIM_AUTH_TERMTYP:
      g_value_set_int (value, self->termtyp);
      break;

    case PROP_TIM_AUTH_TOKEN:
      g_value_set_int64 (value, self->token);
      break;

    case PROP_TIM_AUTH_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_auth_instance_init (TimAuth * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->pwd = NULL;
  object->__isset_pwd = FALSE;
  object->domain = NULL;
  object->__isset_domain = FALSE;
  object->resource = NULL;
  object->__isset_resource = FALSE;
  object->termtyp = 0;
  object->__isset_termtyp = FALSE;
  object->token = 0;
  object->__isset_token = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
}

static void 
tim_auth_finalize (GObject *object)
{
  TimAuth *tobject = TIM_AUTH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->pwd != NULL)
  {
    g_free(tobject->pwd);
    tobject->pwd = NULL;
  }
  if (tobject->domain != NULL)
  {
    g_free(tobject->domain);
    tobject->domain = NULL;
  }
  if (tobject->resource != NULL)
  {
    g_free(tobject->resource);
    tobject->resource = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
}

static void
tim_auth_class_init (TimAuthClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_auth_read;
  struct_class->write = tim_auth_write;

  gobject_class->finalize = tim_auth_finalize;
  gobject_class->get_property = tim_auth_get_property;
  gobject_class->set_property = tim_auth_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_PWD,
     g_param_spec_string ("pwd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_DOMAIN,
     g_param_spec_string ("domain",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_RESOURCE,
     g_param_spec_string ("resource",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_TERMTYP,
     g_param_spec_int ("termtyp",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_TOKEN,
     g_param_spec_int64 ("token",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_auth_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimAuthClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_auth_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimAuth),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_auth_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimAuthType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimPresenceProperties
{
  PROP_TIM_PRESENCE_0,
  PROP_TIM_PRESENCE_ID,
  PROP_TIM_PRESENCE_OFFLINE,
  PROP_TIM_PRESENCE_SUB_STATUS,
  PROP_TIM_PRESENCE_FROM_TID,
  PROP_TIM_PRESENCE_TO_TID,
  PROP_TIM_PRESENCE_TO_LIST,
  PROP_TIM_PRESENCE_SHOW,
  PROP_TIM_PRESENCE_STATUS,
  PROP_TIM_PRESENCE_EXTEND,
  PROP_TIM_PRESENCE_EXTRA
};

/* reads a tim_presence object */
static gint32
tim_presence_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimPresence * this_object = TIM_PRESENCE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->offline, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offline = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->subStatus, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_subStatus = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem28 = NULL;
              if (_elem28 != NULL)
              {
                g_free(_elem28);
                _elem28 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem28, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->toList, _elem28);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_toList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->show, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_show = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->status != NULL)
          {
            g_free(this_object->status);
            this_object->status = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->status, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key29 = NULL;
              gchar * val30 = NULL;
              if (key29 != NULL)
              {
                g_free(key29);
                key29 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key29, error)) < 0)
                return -1;
              xfer += ret;
              if (val30 != NULL)
              {
                g_free(val30);
                val30 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val30, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key29)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key29, (gpointer) val30);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key31 = NULL;
              GByteArray * val32 = NULL;
              if (key31 != NULL)
              {
                g_free(key31);
                key31 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key31, error)) < 0)
                return -1;
              xfer += ret;
              if (val32 != NULL)
              {
                g_free(val32);
                val32 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val32 = g_byte_array_new();
              g_byte_array_append (val32, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->extra && key31)
                g_hash_table_insert ((GHashTable *)this_object->extra, (gpointer) key31, (gpointer) val32);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extra = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_presence_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimPresence * this_object = TIM_PRESENCE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimPresence", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offline == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offline", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->offline, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_subStatus == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "subStatus", T_BYTE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->subStatus, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fromTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toList", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i33;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->toList ? this_object->toList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i33 = 0; i33 < (this_object->toList ? this_object->toList->len : 0); i33++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->toList, i33)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_show == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "show", T_I16, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->show, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_status == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->status, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key34 = NULL;
      gchar * val35 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key34 = keys[i];
        val35 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key34);

        if ((ret = thrift_protocol_write_string (protocol,  key34, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val35, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extra == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extra", T_MAP, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key36 = NULL;
      GByteArray * val37 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extra ? (gint32) g_hash_table_size ((GHashTable *) this_object->extra) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extra)
        g_hash_table_foreach ((GHashTable *) this_object->extra, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key36 = keys[i];
        val37 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->extra), (gpointer) key36);

        if ((ret = thrift_protocol_write_string (protocol,  key36, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val37 ? ((GByteArray *)  val37)->data : NULL,  val37 ? ((GByteArray *)  val37)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_presence_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  TimPresence *self = TIM_PRESENCE (object);

  switch (property_id)
  {
    case PROP_TIM_PRESENCE_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    case PROP_TIM_PRESENCE_OFFLINE:
      self->offline = g_value_get_boolean (value);
      self->__isset_offline = TRUE;
      break;

    case PROP_TIM_PRESENCE_SUB_STATUS:
      self->subStatus = g_value_get_int (value);
      self->__isset_subStatus = TRUE;
      break;

    case PROP_TIM_PRESENCE_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      self->__isset_fromTid = TRUE;
      break;

    case PROP_TIM_PRESENCE_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      self->__isset_toTid = TRUE;
      break;

    case PROP_TIM_PRESENCE_TO_LIST:
      if (self->toList != NULL)
        g_ptr_array_unref (self->toList);
      self->toList = g_value_dup_boxed (value);
      self->__isset_toList = TRUE;
      break;

    case PROP_TIM_PRESENCE_SHOW:
      self->show = g_value_get_int (value);
      self->__isset_show = TRUE;
      break;

    case PROP_TIM_PRESENCE_STATUS:
      if (self->status != NULL)
        g_free (self->status);
      self->status = g_value_dup_string (value);
      self->__isset_status = TRUE;
      break;

    case PROP_TIM_PRESENCE_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    case PROP_TIM_PRESENCE_EXTRA:
      if (self->extra != NULL)
        g_hash_table_unref (self->extra);
      self->extra = g_value_dup_boxed (value);
      self->__isset_extra = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_presence_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  TimPresence *self = TIM_PRESENCE (object);

  switch (property_id)
  {
    case PROP_TIM_PRESENCE_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_TIM_PRESENCE_OFFLINE:
      g_value_set_boolean (value, self->offline);
      break;

    case PROP_TIM_PRESENCE_SUB_STATUS:
      g_value_set_int (value, self->subStatus);
      break;

    case PROP_TIM_PRESENCE_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_PRESENCE_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_PRESENCE_TO_LIST:
      g_value_set_boxed (value, self->toList);
      break;

    case PROP_TIM_PRESENCE_SHOW:
      g_value_set_int (value, self->show);
      break;

    case PROP_TIM_PRESENCE_STATUS:
      g_value_set_string (value, self->status);
      break;

    case PROP_TIM_PRESENCE_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    case PROP_TIM_PRESENCE_EXTRA:
      g_value_set_boxed (value, self->extra);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_presence_instance_init (TimPresence * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
  object->offline = 0;
  object->__isset_offline = FALSE;
  object->subStatus = 0;
  object->__isset_subStatus = FALSE;
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->__isset_fromTid = FALSE;
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->__isset_toTid = FALSE;
  object->toList = g_ptr_array_new_with_free_func (g_free);
  object->__isset_toList = FALSE;
  object->show = 0;
  object->__isset_show = FALSE;
  object->status = NULL;
  object->__isset_status = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
  object->extra = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_extra = FALSE;
}

static void 
tim_presence_finalize (GObject *object)
{
  TimPresence *tobject = TIM_PRESENCE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->toList != NULL)
  {
    g_ptr_array_unref (tobject->toList);
    tobject->toList = NULL;
  }
  if (tobject->status != NULL)
  {
    g_free(tobject->status);
    tobject->status = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
  if (tobject->extra != NULL)
  {
    g_hash_table_destroy (tobject->extra);
    tobject->extra = NULL;
  }
}

static void
tim_presence_class_init (TimPresenceClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_presence_read;
  struct_class->write = tim_presence_write;

  gobject_class->finalize = tim_presence_finalize;
  gobject_class->get_property = tim_presence_get_property;
  gobject_class->set_property = tim_presence_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_OFFLINE,
     g_param_spec_boolean ("offline",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_SUB_STATUS,
     g_param_spec_int ("subStatus",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_TO_LIST,
     g_param_spec_boxed ("toList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_SHOW,
     g_param_spec_int ("show",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_STATUS,
     g_param_spec_string ("status",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PRESENCE_EXTRA,
     g_param_spec_boxed ("extra",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_presence_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimPresenceClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_presence_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimPresence),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_presence_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimPresenceType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimMessageProperties
{
  PROP_TIM_MESSAGE_0,
  PROP_TIM_MESSAGE_MS_TYPE,
  PROP_TIM_MESSAGE_OD_TYPE,
  PROP_TIM_MESSAGE_ID,
  PROP_TIM_MESSAGE_MID,
  PROP_TIM_MESSAGE_BN_TYPE,
  PROP_TIM_MESSAGE_FROM_TID,
  PROP_TIM_MESSAGE_TO_TID,
  PROP_TIM_MESSAGE_ROOM_TID,
  PROP_TIM_MESSAGE_DATA_BINARY,
  PROP_TIM_MESSAGE_DATA_STRING,
  PROP_TIM_MESSAGE_IS_OFFLINE,
  PROP_TIM_MESSAGE_TIMESTAMP,
  PROP_TIM_MESSAGE_UDTYPE,
  PROP_TIM_MESSAGE_UDSHOW,
  PROP_TIM_MESSAGE_EXTEND,
  PROP_TIM_MESSAGE_EXTRA
};

/* reads a tim_message object */
static gint32
tim_message_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimMessage * this_object = TIM_MESSAGE(object);
  gboolean isset_msType = FALSE;
  gboolean isset_odType = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->msType, error)) < 0)
            return -1;
          xfer += ret;
          isset_msType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->odType, error)) < 0)
            return -1;
          xfer += ret;
          isset_odType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->mid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bnType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bnType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->roomTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_roomTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->dataBinary != NULL)
          {
            g_free(this_object->dataBinary);
            this_object->dataBinary = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->dataBinary = g_byte_array_new();
          g_byte_array_append (this_object->dataBinary, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_dataBinary = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->dataString != NULL)
          {
            g_free(this_object->dataString);
            this_object->dataString = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->dataString, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dataString = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isOffline, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_isOffline = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->udtype, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_udtype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->udshow, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_udshow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key38 = NULL;
              gchar * val39 = NULL;
              if (key38 != NULL)
              {
                g_free(key38);
                key38 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key38, error)) < 0)
                return -1;
              xfer += ret;
              if (val39 != NULL)
              {
                g_free(val39);
                val39 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val39, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extend && key38)
                g_hash_table_insert ((GHashTable *)this_object->extend, (gpointer) key38, (gpointer) val39);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key40 = NULL;
              GByteArray * val41 = NULL;
              if (key40 != NULL)
              {
                g_free(key40);
                key40 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key40, error)) < 0)
                return -1;
              xfer += ret;
              if (val41 != NULL)
              {
                g_free(val41);
                val41 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val41 = g_byte_array_new();
              g_byte_array_append (val41, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->extra && key40)
                g_hash_table_insert ((GHashTable *)this_object->extra, (gpointer) key40, (gpointer) val41);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extra = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_msType)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_odType)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_message_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimMessage * this_object = TIM_MESSAGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimMessage", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "msType", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->msType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "odType", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->odType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->mid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bnType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bnType", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->bnType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fromTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_roomTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomTid", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->roomTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dataBinary == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dataBinary", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->dataBinary ? ((GByteArray *) this_object->dataBinary)->data : NULL, this_object->dataBinary ? ((GByteArray *) this_object->dataBinary)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dataString == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dataString", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->dataString, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_isOffline == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "isOffline", T_BOOL, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->isOffline, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_udtype == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "udtype", T_I16, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->udtype, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_udshow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "udshow", T_I16, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->udshow, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extend == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extend", T_MAP, 15, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key42 = NULL;
      gchar * val43 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extend ? (gint32) g_hash_table_size ((GHashTable *) this_object->extend) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extend)
        g_hash_table_foreach ((GHashTable *) this_object->extend, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key42 = keys[i];
        val43 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extend), (gpointer) key42);

        if ((ret = thrift_protocol_write_string (protocol,  key42, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val43, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extra == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extra", T_MAP, 16, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key44 = NULL;
      GByteArray * val45 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extra ? (gint32) g_hash_table_size ((GHashTable *) this_object->extra) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extra)
        g_hash_table_foreach ((GHashTable *) this_object->extra, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key44 = keys[i];
        val45 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->extra), (gpointer) key44);

        if ((ret = thrift_protocol_write_string (protocol,  key44, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val45 ? ((GByteArray *)  val45)->data : NULL,  val45 ? ((GByteArray *)  val45)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_message_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TimMessage *self = TIM_MESSAGE (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_MS_TYPE:
      self->msType = g_value_get_int (value);
      break;

    case PROP_TIM_MESSAGE_OD_TYPE:
      self->odType = g_value_get_int (value);
      break;

    case PROP_TIM_MESSAGE_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    case PROP_TIM_MESSAGE_MID:
      self->mid = g_value_get_int64 (value);
      self->__isset_mid = TRUE;
      break;

    case PROP_TIM_MESSAGE_BN_TYPE:
      self->bnType = g_value_get_int (value);
      self->__isset_bnType = TRUE;
      break;

    case PROP_TIM_MESSAGE_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      self->__isset_fromTid = TRUE;
      break;

    case PROP_TIM_MESSAGE_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      self->__isset_toTid = TRUE;
      break;

    case PROP_TIM_MESSAGE_ROOM_TID:
      if (self->roomTid != NULL)
        g_object_unref (self->roomTid);
      self->roomTid = g_value_dup_object (value);
      self->__isset_roomTid = TRUE;
      break;

    case PROP_TIM_MESSAGE_DATA_BINARY:
      if (self->dataBinary != NULL)
        g_byte_array_unref (self->dataBinary);
      self->dataBinary = g_value_dup_boxed (value);
      self->__isset_dataBinary = TRUE;
      break;

    case PROP_TIM_MESSAGE_DATA_STRING:
      if (self->dataString != NULL)
        g_free (self->dataString);
      self->dataString = g_value_dup_string (value);
      self->__isset_dataString = TRUE;
      break;

    case PROP_TIM_MESSAGE_IS_OFFLINE:
      self->isOffline = g_value_get_boolean (value);
      self->__isset_isOffline = TRUE;
      break;

    case PROP_TIM_MESSAGE_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_TIM_MESSAGE_UDTYPE:
      self->udtype = g_value_get_int (value);
      self->__isset_udtype = TRUE;
      break;

    case PROP_TIM_MESSAGE_UDSHOW:
      self->udshow = g_value_get_int (value);
      self->__isset_udshow = TRUE;
      break;

    case PROP_TIM_MESSAGE_EXTEND:
      if (self->extend != NULL)
        g_hash_table_unref (self->extend);
      self->extend = g_value_dup_boxed (value);
      self->__isset_extend = TRUE;
      break;

    case PROP_TIM_MESSAGE_EXTRA:
      if (self->extra != NULL)
        g_hash_table_unref (self->extra);
      self->extra = g_value_dup_boxed (value);
      self->__isset_extra = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_message_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TimMessage *self = TIM_MESSAGE (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_MS_TYPE:
      g_value_set_int (value, self->msType);
      break;

    case PROP_TIM_MESSAGE_OD_TYPE:
      g_value_set_int (value, self->odType);
      break;

    case PROP_TIM_MESSAGE_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_TIM_MESSAGE_MID:
      g_value_set_int64 (value, self->mid);
      break;

    case PROP_TIM_MESSAGE_BN_TYPE:
      g_value_set_int (value, self->bnType);
      break;

    case PROP_TIM_MESSAGE_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_MESSAGE_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_MESSAGE_ROOM_TID:
      g_value_set_object (value, self->roomTid);
      break;

    case PROP_TIM_MESSAGE_DATA_BINARY:
      g_value_set_boxed (value, self->dataBinary);
      break;

    case PROP_TIM_MESSAGE_DATA_STRING:
      g_value_set_string (value, self->dataString);
      break;

    case PROP_TIM_MESSAGE_IS_OFFLINE:
      g_value_set_boolean (value, self->isOffline);
      break;

    case PROP_TIM_MESSAGE_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_TIM_MESSAGE_UDTYPE:
      g_value_set_int (value, self->udtype);
      break;

    case PROP_TIM_MESSAGE_UDSHOW:
      g_value_set_int (value, self->udshow);
      break;

    case PROP_TIM_MESSAGE_EXTEND:
      g_value_set_boxed (value, self->extend);
      break;

    case PROP_TIM_MESSAGE_EXTRA:
      g_value_set_boxed (value, self->extra);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_message_instance_init (TimMessage * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->msType = 0;
  object->odType = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->mid = 0;
  object->__isset_mid = FALSE;
  object->bnType = 0;
  object->__isset_bnType = FALSE;
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->__isset_fromTid = FALSE;
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->__isset_toTid = FALSE;
  object->roomTid = g_object_new (TYPE_TID, NULL);
  object->__isset_roomTid = FALSE;
  object->dataBinary = NULL;
  object->__isset_dataBinary = FALSE;
  object->dataString = NULL;
  object->__isset_dataString = FALSE;
  object->isOffline = 0;
  object->__isset_isOffline = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->udtype = 0;
  object->__isset_udtype = FALSE;
  object->udshow = 0;
  object->__isset_udshow = FALSE;
  object->extend = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extend = FALSE;
  object->extra = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_extra = FALSE;
}

static void 
tim_message_finalize (GObject *object)
{
  TimMessage *tobject = TIM_MESSAGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->roomTid != NULL)
  {
    g_object_unref(tobject->roomTid);
    tobject->roomTid = NULL;
  }
  if (tobject->dataBinary != NULL)
  {
    thrift_string_free(tobject->dataBinary);
    tobject->dataBinary = NULL;
  }
  if (tobject->dataString != NULL)
  {
    g_free(tobject->dataString);
    tobject->dataString = NULL;
  }
  if (tobject->extend != NULL)
  {
    g_hash_table_destroy (tobject->extend);
    tobject->extend = NULL;
  }
  if (tobject->extra != NULL)
  {
    g_hash_table_destroy (tobject->extra);
    tobject->extra = NULL;
  }
}

static void
tim_message_class_init (TimMessageClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_message_read;
  struct_class->write = tim_message_write;

  gobject_class->finalize = tim_message_finalize;
  gobject_class->get_property = tim_message_get_property;
  gobject_class->set_property = tim_message_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_MS_TYPE,
     g_param_spec_int ("msType",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_OD_TYPE,
     g_param_spec_int ("odType",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_MID,
     g_param_spec_int64 ("mid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_BN_TYPE,
     g_param_spec_int ("bnType",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_ROOM_TID,
     g_param_spec_object ("roomTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_DATA_BINARY,
     g_param_spec_boxed ("dataBinary",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_DATA_STRING,
     g_param_spec_string ("dataString",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_IS_OFFLINE,
     g_param_spec_boolean ("isOffline",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_UDTYPE,
     g_param_spec_int ("udtype",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_UDSHOW,
     g_param_spec_int ("udshow",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_EXTEND,
     g_param_spec_boxed ("extend",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_EXTRA,
     g_param_spec_boxed ("extra",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_message_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimMessageClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_message_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimMessage),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_message_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimMessageType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimStreamProperties
{
  PROP_TIM_STREAM_0,
  PROP_TIM_STREAM_ID,
  PROP_TIM_STREAM_V_NODE,
  PROP_TIM_STREAM_DTYPE,
  PROP_TIM_STREAM_BODY,
  PROP_TIM_STREAM_FROM_NODE
};

/* reads a tim_stream object */
static gint32
tim_stream_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimStream * this_object = TIM_STREAM(object);
  gboolean isset_id = FALSE;
  gboolean isset_VNode = FALSE;
  gboolean isset_fromNode = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->VNode != NULL)
          {
            g_free(this_object->VNode);
            this_object->VNode = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->VNode, error)) < 0)
            return -1;
          xfer += ret;
          isset_VNode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->dtype, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dtype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->body != NULL)
          {
            g_free(this_object->body);
            this_object->body = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->body = g_byte_array_new();
          g_byte_array_append (this_object->body, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_body = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->fromNode != NULL)
          {
            g_free(this_object->fromNode);
            this_object->fromNode = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->fromNode, error)) < 0)
            return -1;
          xfer += ret;
          isset_fromNode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_id)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_VNode)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_fromNode)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_stream_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimStream * this_object = TIM_STREAM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimStream", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "VNode", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->VNode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_dtype == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dtype", T_BYTE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->dtype, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_body == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "body", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->body ? ((GByteArray *) this_object->body)->data : NULL, this_object->body ? ((GByteArray *) this_object->body)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "fromNode", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->fromNode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_stream_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TimStream *self = TIM_STREAM (object);

  switch (property_id)
  {
    case PROP_TIM_STREAM_ID:
      self->id = g_value_get_int64 (value);
      break;

    case PROP_TIM_STREAM_V_NODE:
      if (self->VNode != NULL)
        g_free (self->VNode);
      self->VNode = g_value_dup_string (value);
      break;

    case PROP_TIM_STREAM_DTYPE:
      self->dtype = g_value_get_int (value);
      self->__isset_dtype = TRUE;
      break;

    case PROP_TIM_STREAM_BODY:
      if (self->body != NULL)
        g_byte_array_unref (self->body);
      self->body = g_value_dup_boxed (value);
      self->__isset_body = TRUE;
      break;

    case PROP_TIM_STREAM_FROM_NODE:
      if (self->fromNode != NULL)
        g_free (self->fromNode);
      self->fromNode = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_stream_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TimStream *self = TIM_STREAM (object);

  switch (property_id)
  {
    case PROP_TIM_STREAM_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_TIM_STREAM_V_NODE:
      g_value_set_string (value, self->VNode);
      break;

    case PROP_TIM_STREAM_DTYPE:
      g_value_set_int (value, self->dtype);
      break;

    case PROP_TIM_STREAM_BODY:
      g_value_set_boxed (value, self->body);
      break;

    case PROP_TIM_STREAM_FROM_NODE:
      g_value_set_string (value, self->fromNode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_stream_instance_init (TimStream * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->VNode = NULL;
  object->dtype = 0;
  object->__isset_dtype = FALSE;
  object->body = NULL;
  object->__isset_body = FALSE;
  object->fromNode = NULL;
}

static void 
tim_stream_finalize (GObject *object)
{
  TimStream *tobject = TIM_STREAM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->VNode != NULL)
  {
    g_free(tobject->VNode);
    tobject->VNode = NULL;
  }
  if (tobject->body != NULL)
  {
    thrift_string_free(tobject->body);
    tobject->body = NULL;
  }
  if (tobject->fromNode != NULL)
  {
    g_free(tobject->fromNode);
    tobject->fromNode = NULL;
  }
}

static void
tim_stream_class_init (TimStreamClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_stream_read;
  struct_class->write = tim_stream_write;

  gobject_class->finalize = tim_stream_finalize;
  gobject_class->get_property = tim_stream_get_property;
  gobject_class->set_property = tim_stream_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_STREAM_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_STREAM_V_NODE,
     g_param_spec_string ("VNode",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_STREAM_DTYPE,
     g_param_spec_int ("dtype",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_STREAM_BODY,
     g_param_spec_boxed ("body",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_STREAM_FROM_NODE,
     g_param_spec_string ("fromNode",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_stream_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimStreamClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_stream_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimStream),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_stream_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimStreamType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimNodesProperties
{
  PROP_TIM_NODES_0,
  PROP_TIM_NODES_NTYPE,
  PROP_TIM_NODES_NODELIST,
  PROP_TIM_NODES_USERMAP,
  PROP_TIM_NODES_ROOMMAP,
  PROP_TIM_NODES_NODE
};

/* reads a tim_nodes object */
static gint32
tim_nodes_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimNodes * this_object = TIM_NODES(object);
  gboolean isset_ntype = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->ntype, error)) < 0)
            return -1;
          xfer += ret;
          isset_ntype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem46 = NULL;
              if (_elem46 != NULL)
              {
                g_free(_elem46);
                _elem46 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem46, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->nodelist, _elem46);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_nodelist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key47 = NULL;
              TimUserBean * val48 = NULL;
              if (key47 != NULL)
              {
                g_free(key47);
                key47 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key47, error)) < 0)
                return -1;
              xfer += ret;
              if ( val48 != NULL)
              {
                g_object_unref (val48);
              }
              val48 = g_object_new (TYPE_TIM_USER_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val48), protocol, error)) < 0)
              {
                g_object_unref (val48);
                return -1;
              }
              xfer += ret;
              if (this_object->usermap && key47)
                g_hash_table_insert ((GHashTable *)this_object->usermap, (gpointer) key47, (gpointer) val48);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_usermap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key49 = NULL;
              TimRoomBean * val50 = NULL;
              if (key49 != NULL)
              {
                g_free(key49);
                key49 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key49, error)) < 0)
                return -1;
              xfer += ret;
              if ( val50 != NULL)
              {
                g_object_unref (val50);
              }
              val50 = g_object_new (TYPE_TIM_ROOM_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val50), protocol, error)) < 0)
              {
                g_object_unref (val50);
                return -1;
              }
              xfer += ret;
              if (this_object->roommap && key49)
                g_hash_table_insert ((GHashTable *)this_object->roommap, (gpointer) key49, (gpointer) val50);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_roommap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->node != NULL)
          {
            g_free(this_object->node);
            this_object->node = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->node, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_ntype)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_nodes_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimNodes * this_object = TIM_NODES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimNodes", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ntype", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->ntype, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_nodelist == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "nodelist", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i51;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->nodelist ? this_object->nodelist->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i51 = 0; i51 < (this_object->nodelist ? this_object->nodelist->len : 0); i51++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->nodelist, i51)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_usermap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "usermap", T_MAP, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key52 = NULL;
      TimUserBean * val53 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->usermap ? (gint32) g_hash_table_size ((GHashTable *) this_object->usermap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->usermap)
        g_hash_table_foreach ((GHashTable *) this_object->usermap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key52 = keys[i];
        val53 = (TimUserBean *) g_hash_table_lookup (((GHashTable *) this_object->usermap), (gpointer) key52);

        if ((ret = thrift_protocol_write_string (protocol,  key52, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val53), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_roommap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "roommap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key54 = NULL;
      TimRoomBean * val55 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->roommap ? (gint32) g_hash_table_size ((GHashTable *) this_object->roommap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->roommap)
        g_hash_table_foreach ((GHashTable *) this_object->roommap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key54 = keys[i];
        val55 = (TimRoomBean *) g_hash_table_lookup (((GHashTable *) this_object->roommap), (gpointer) key54);

        if ((ret = thrift_protocol_write_string (protocol,  key54, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val55), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->node, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_nodes_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimNodes *self = TIM_NODES (object);

  switch (property_id)
  {
    case PROP_TIM_NODES_NTYPE:
      self->ntype = g_value_get_int (value);
      break;

    case PROP_TIM_NODES_NODELIST:
      if (self->nodelist != NULL)
        g_ptr_array_unref (self->nodelist);
      self->nodelist = g_value_dup_boxed (value);
      self->__isset_nodelist = TRUE;
      break;

    case PROP_TIM_NODES_USERMAP:
      if (self->usermap != NULL)
        g_hash_table_unref (self->usermap);
      self->usermap = g_value_dup_boxed (value);
      self->__isset_usermap = TRUE;
      break;

    case PROP_TIM_NODES_ROOMMAP:
      if (self->roommap != NULL)
        g_hash_table_unref (self->roommap);
      self->roommap = g_value_dup_boxed (value);
      self->__isset_roommap = TRUE;
      break;

    case PROP_TIM_NODES_NODE:
      if (self->node != NULL)
        g_free (self->node);
      self->node = g_value_dup_string (value);
      self->__isset_node = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_nodes_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimNodes *self = TIM_NODES (object);

  switch (property_id)
  {
    case PROP_TIM_NODES_NTYPE:
      g_value_set_int (value, self->ntype);
      break;

    case PROP_TIM_NODES_NODELIST:
      g_value_set_boxed (value, self->nodelist);
      break;

    case PROP_TIM_NODES_USERMAP:
      g_value_set_boxed (value, self->usermap);
      break;

    case PROP_TIM_NODES_ROOMMAP:
      g_value_set_boxed (value, self->roommap);
      break;

    case PROP_TIM_NODES_NODE:
      g_value_set_string (value, self->node);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_nodes_instance_init (TimNodes * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ntype = 0;
  object->nodelist = g_ptr_array_new_with_free_func (g_free);
  object->__isset_nodelist = FALSE;
  object->usermap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_usermap = FALSE;
  object->roommap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_roommap = FALSE;
  object->node = NULL;
  object->__isset_node = FALSE;
}

static void 
tim_nodes_finalize (GObject *object)
{
  TimNodes *tobject = TIM_NODES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->nodelist != NULL)
  {
    g_ptr_array_unref (tobject->nodelist);
    tobject->nodelist = NULL;
  }
  if (tobject->usermap != NULL)
  {
    g_hash_table_destroy (tobject->usermap);
    tobject->usermap = NULL;
  }
  if (tobject->roommap != NULL)
  {
    g_hash_table_destroy (tobject->roommap);
    tobject->roommap = NULL;
  }
  if (tobject->node != NULL)
  {
    g_free(tobject->node);
    tobject->node = NULL;
  }
}

static void
tim_nodes_class_init (TimNodesClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_nodes_read;
  struct_class->write = tim_nodes_write;

  gobject_class->finalize = tim_nodes_finalize;
  gobject_class->get_property = tim_nodes_get_property;
  gobject_class->set_property = tim_nodes_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODES_NTYPE,
     g_param_spec_int ("ntype",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODES_NODELIST,
     g_param_spec_boxed ("nodelist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODES_USERMAP,
     g_param_spec_boxed ("usermap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODES_ROOMMAP,
     g_param_spec_boxed ("roommap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODES_NODE,
     g_param_spec_string ("node",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_nodes_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimNodesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_nodes_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimNodes),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_nodes_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimNodesType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimMessageListProperties
{
  PROP_TIM_MESSAGE_LIST_0,
  PROP_TIM_MESSAGE_LIST_ID,
  PROP_TIM_MESSAGE_LIST_MESSAGE_LIST
};

/* reads a tim_message_list object */
static gint32
tim_message_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimMessageList * this_object = TIM_MESSAGE_LIST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimMessage * _elem56 = NULL;
              if ( _elem56 != NULL)
              {
                g_object_unref (_elem56);
              }
              _elem56 = g_object_new (TYPE_TIM_MESSAGE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem56), protocol, error)) < 0)
              {
                g_object_unref (_elem56);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->messageList, _elem56);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_messageList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_message_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimMessageList * this_object = TIM_MESSAGE_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimMessageList", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_messageList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "messageList", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i57;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->messageList ? this_object->messageList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i57 = 0; i57 < (this_object->messageList ? this_object->messageList->len : 0); i57++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->messageList, i57))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_message_list_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TimMessageList *self = TIM_MESSAGE_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_LIST_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    case PROP_TIM_MESSAGE_LIST_MESSAGE_LIST:
      if (self->messageList != NULL)
        g_ptr_array_unref (self->messageList);
      self->messageList = g_value_dup_boxed (value);
      self->__isset_messageList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_message_list_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TimMessageList *self = TIM_MESSAGE_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_LIST_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_TIM_MESSAGE_LIST_MESSAGE_LIST:
      g_value_set_boxed (value, self->messageList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_message_list_instance_init (TimMessageList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
  object->messageList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_messageList = FALSE;
}

static void 
tim_message_list_finalize (GObject *object)
{
  TimMessageList *tobject = TIM_MESSAGE_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->messageList != NULL)
  {
    g_ptr_array_unref (tobject->messageList);
    tobject->messageList = NULL;
  }
}

static void
tim_message_list_class_init (TimMessageListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_message_list_read;
  struct_class->write = tim_message_list_write;

  gobject_class->finalize = tim_message_list_finalize;
  gobject_class->get_property = tim_message_list_get_property;
  gobject_class->set_property = tim_message_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_LIST_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_LIST_MESSAGE_LIST,
     g_param_spec_boxed ("messageList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
tim_message_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimMessageListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_message_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimMessageList),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_message_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimMessageListType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

